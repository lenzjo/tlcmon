0000-                  4
0000-                  5       ###############################################################################
0000-                  6       #
0000-                  7       #       My monitor/os kernal for the modified RC6502 sbc
0000-                  8       #
0000-                  9       #       ACIA functionality                    - working 28/04/21 - v0.0.1
0000-                 10       #       ACIA Int. & Int Vector Table          - working 29/04/21 - v0.0.2
0000-                 11       # cmd input
0000-                 12       #   v1 - cmd buff & edit                - working 24/08/21 - v0.0.3
0000-                 13       #   v2 - parse cmds & args              - working 25/08/21 - v0.0.4
0000-                 14       #   v3 - execute a cmd via table        - working 27/08/21 - v0.1.0
0000-                 15       #
0000-                 16       # Cmds:
0000-                 17       #   peek                                - working 27/08/21 - v0.1.0
0000-                 18       #   poke                                - working 27/08/21 - v0.1.0
0000-                 19       #   dump
0000-                 20       #   copy
0000-                 21       #   fill
0000-                 22       #   go
0000-                 23       #   help
0000-                 24       #   dism
0000-                 25       #   conv
0000-                 26       #   prog
0000-                 27       #   xload
0000-                 28       ###############################################################################
0000-                 29
0000-                 30       #=-=-=-= TLCmon Version number =-=-=-=
0000-                 31       VerMaj            .EQ 0
0000-                 32       VerMin            .EQ 0
0004-                 33       VerMnt            .EQ 4
0000-                 34
0000-                 35
0000-                 36       #=-=-=-= Memory starts & limits =-=-=-=
0000-                 37       RAM_Base          .EQ $0000
0000-                 38       RAM_End           .EQ RAM_Base + $7FFF
0000-                 39
C000-                 40       ROM_Base          .EQ $C000
0000-                 41
0000-                 42
0000-                 43       ###############################################################################
0000-                 44       #                 Hardware constants
0000-                 45       ###############################################################################
0000-                 46
0000-                 47       #=-=-=-= 6850 ACIA - hardware & constants =-=-=-=
0000-                 48
0000-                 49                         .IN devs/ACIA1_map.inc
0000-            I     1       #=====================================================================
0000-            I     2       # I/O starts at $A400.
0000-            I     3       # ACIA - 68B50
0000-            I     4       #=====================================================================
0000-            I     5
A200-            I     6       ACIA1             .EQ $A200
0000-            I     7
A200-            I     8       ACIABase          .EQ ACIA1
A200-            I     9       ACIA_Control      .EQ ACIABase+$0       # Control reg
A200-            I    10       ACIA_Status       .EQ ACIABase+$0       # Status reg
A201-            I    11       ACIA_Tx           .EQ ACIABase+$1       # Transmit buffer reg
A201-            I    12       ACIA_Rx           .EQ ACIABase+$1       # Receive buffer reg
0000-                 50
0000-                 51                         .IN devs/ACIA1_con.inc
0000-            I     1       #=====================================================================
0000-            I     2       #                 ACIA CONSTANTS
0000-            I     3       #=====================================================================
0000-            I     4
0000-            I     5       # Control register bit fields
0080-            I     6       ACIA_RXI_EN       .EQ %1000.0000        # Receive interrupt enable
0020-            I     7       ACIA_TXI_EN       .EQ %0010.0000        # Transmit interrupt enable, /rts low
009F-            I     8       ACIA_TXI_DS       .EQ %1001.1111        # Transmit interrupt disable, /rts low (AND)
0014-            I     9       ACIA_N_8_1        .EQ %0001.0100        # No parity, 8 bit data, 1 stop (see docs)
0001-            I    10       ACIA_DIV_16       .EQ %0000.0001        # Divide tx & rx clock by 16, sample middle
0003-            I    11       ACIA_RESET        .EQ %0000.0011        # Master reset
0015-            I    12       ACIA_INIT         .EQ %0001.0101        # No parity, 8 bit data, 1 stop, Divide by 16
0000-            I    13
0000-            I    14       # Status register bit fields
0001-            I    15       ACIA_RDRF         .EQ %00000001         # Receive Data Register Full
0002-            I    16       ACIA_TDRE         .EQ %00000010         # Transmit Data Register Empty
0004-            I    17       ACIA_DCD          .EQ %00000100         # Data Carrier Detect line
0008-            I    18       ACIA_CTS          .EQ %00001000         # Clear To Send line
0010-            I    19       ACIA_ER_F         .EQ %00010000         # Error- Framing
0020-            I    20       ACIA_ER_O         .EQ %00100000         # Error- Overrun
0040-            I    21       ACIA_ER_P         .EQ %01000000         # Error- Parity
0080-            I    22       ACIA_IRQ          .EQ %10000000         # Interrupt Request
0000-                 52
0000-                 53       #=-=-=-= 6522 VIA - hardware =-=-=-=
0000-                 54                         .IN devs/VIA1_map.inc
0000-            I     1       #=====================================================================
0000-            I     2       # I/O starts at $A220.
0000-            I     3       # VIA - W65c22
0000-            I     4       #=====================================================================
0000-            I     5
A220-            I     6       VIA1              .EQ $A220
0000-            I     7
A220-            I     8       VIA1Base          .EQ VIA1
0000-            I     9
A220-            I    10       VIA1_IRB          .EQ VIA1Base+$0       # Input/output Register Port B
A220-            I    11       VIA1_ORB          .EQ VIA1Base+$0       # Input/output Register Port B
A221-            I    12       VIA1_IRA          .EQ VIA1Base+$1       # Input/output Register Port A
A221-            I    13       VIA1_ORA          .EQ VIA1Base+$1       # Input/output Register Port A
A222-            I    14       VIA1_DDRB         .EQ VIA1Base+$2       # Data Direction Register Port B
A223-            I    15       VIA1_DDRA         .EQ VIA1Base+$3       # Data Direction Register Port A
A224-            I    16       VIA1_T1CL         .EQ VIA1Base+$4       # T1 Low Order Latches & Counter
A225-            I    17       VIA1_T1CH         .EQ VIA1Base+$5       # T1 High Order Counter
A226-            I    18       VIA1_T1LL         .EQ VIA1Base+$6       # T1 Low Order Latches
A227-            I    19       VIA1_T1LH         .EQ VIA1Base+$7       # T1 High Order Latches
A228-            I    20       VIA1_T2CL         .EQ VIA1Base+$8       # T2 Low Order Latches & Counter
A229-            I    21       VIA1_T2CH         .EQ VIA1Base+$9       # T2 High Order Counter
A22A-            I    22       VIA1_SR           .EQ VIA1Base+$A       # Shift Register
A22B-            I    23       VIA1_ACR          .EQ VIA1Base+$B       # Auxillary Control Register
A22C-            I    24       VIA1_PCR          .EQ VIA1Base+$C       # Peripheral Control Register
A22D-            I    25       VIA1_IFR          .EQ VIA1Base+$D       # Interrupt Flag Register
A22E-            I    26       VIA1_IER          .EQ VIA1Base+$E       # Interrupt Enable Register
A22F-            I    27       VIA1_IRA_NHS      .EQ VIA1Base+$F       # Same as VIA1_IORA except no "Handshake"
A22F-            I    28       VIA1_ORA_NHS      .EQ VIA1Base+$F       # Same as VIA1_IORA except no "Handshake"
0000-                 55
0000-                 56       ###############################################################################
0000-                 57       #                 Program constants
0000-                 58       ###############################################################################
0000-                 59
0000-                 60       #=-=-=-= ASCII codes =-=-=-=
0000-                 61
0000-                 62                         .IN misc/ascii_con.inc
0000-            I     1       #=====================================================================
0000-            I     2       # ASCII and Control Character Constants
0000-            I     3       #=====================================================================
0000-            I     4
0000-            I     5
0000-            I     6       NULL              .EQ $00
0007-            I     7       BELL              .EQ $07
0008-            I     8       BS                .EQ $08
0009-            I     9       TAB               .EQ $09
000A-            I    10       LF                .EQ $0A
000C-            I    11       CLEAR_SCREEN      .EQ $0C
000D-            I    12       CR                .EQ $0D
0000-            I    13
001B-            I    14       ESC               .EQ $1B               # ESC - reserved for ANSI seqences
001C-            I    15       CUR_RIGHT         .EQ $1C
001D-            I    16       CUR_LEFT          .EQ $1D
001E-            I    17       CUR_UP            .EQ $1E
001F-            I    18       CUR_DOWN          .EQ $1F
0000-            I    19
007F-            I    20       DEL               .EQ $7F
0000-            I    21
0020-            I    22       SPC               .EQ $20
0021-            I    23       BANG              .EQ $21               # !
0022-            I    24       QUOTE             .EQ $22               # "
0023-            I    25       HASH              .EQ $23               # #
0024-            I    26       DOLLAR            .EQ $24               # $
0028-            I    27       LPAREN            .EQ $28               # (
0029-            I    28       RPAREN            .EQ $29               # )
002A-            I    29       STAR              .EQ $2A               # *
002C-            I    30       COMMA             .EQ $2C               # ,
002D-            I    31       MINUS             .EQ $2D               # -
002E-            I    32       PERIOD            .EQ $2E               # .
003A-            I    33       COLON             .EQ $3A               # :
003D-            I    34       EQUALS            .EQ $3D               # =
003E-            I    35       REDIR_OUT         .EQ $3E               # >
003F-            I    36       HELPME            .EQ $3F               # ?
005B-            I    37       LSBRACKET         .EQ $5B               # [
005D-            I    38       RSBRACKET         .EQ $5D               # ]
007C-            I    39       PIPE              .EQ $7C               # |
0000-                 63
0000-                 64       #=-=-=-= ASCII codes =-=-=-=
0000-                 65
0000-                 66
0000-                 67
0000-                 68       #=-=-=-= My Macros =-=-=-=
0000-                 69                         .IN misc/macros.inc
0000-            I     1       #=====================================================================
0000-            I     2       # My Macros to make coding more readable
0000-            I     3       #=====================================================================
0000-            I     4
0000-            I     5       #====  Move an address into regs A & Y  ====
0000-            I     6       CPYMSPTR          .MA   ADDR
0000-            I     7                         lda #]1
0000-            I     8                         ldy /]1
0000-            I     9                         .EM
0000-            I    10
0000-            I    11
0000-            I    12       ;====  Multiply Acc by 16  ====
0000-            I    13       MULTAx16          .MA
0000-            I    14                         clc
0000-            I    15                         asl a
0000-            I    16                         asl a
0000-            I    17                         asl a
0000-            I    18                         asl a
0000-            I    19                         .EM
0000-            I    20
0000-            I    21
0000-            I    22       ;====  Multiply Acc by 8  ====
0000-            I    23       MULTAx8           .MA
0000-            I    24                         clc
0000-            I    25                         asl a
0000-            I    26                         asl a
0000-            I    27                         asl a
0000-            I    28                         .EM
0000-            I    29
0000-            I    30
0000-            I    31       ;====  Multiply a word by 2
0000-            I    32       MULTW2            .MA WORD
0000-            I    33                         asl ]1
0000-            I    34                         rol   ]1+1
0000-            I    35                         .EM
0000-            I    36
0000-            I    37
0000-            I    38       ;====  Add two mem regs together and save in 1st
0000-            I    39       ADDW              .MA WORDA, WORDB
0000-            I    40                         clc
0000-            I    41                         lda ]1
0000-            I    42                         adc ]2
0000-            I    43                         sta ]1
0000-            I    44                         lda ]1+1
0000-            I    45                         adc ]2+1
0000-            I    46                         sta ]1+1
0000-            I    47                         .EM
0000-            I    48
0000-            I    49
0000-            I    50       ;==== Copy a Word
0000-            I    51       CPYW              .MA WORDA, WORDB
0000-            I    52                         lda ]1
0000-            I    53                         sta ]2
0000-            I    54                         lda ]1+1
0000-            I    55                         sta ]2+1
0000-            I    56                         .EM
0000-            I    57
0000-            I    58
0000-            I    59       ;====  Copy addr into ptr
0000-            I    60       CPYA2P            .MA ADDR, PTR
0000-            I    61                         lda #]1
0000-            I    62                         sta ]2
0000-            I    63                         lda /]1
0000-            I    64                         sta ]2+1
0000-            I    65                         .EM
0000-            I    66
0000-            I    67
0000-            I    68       ;====  Compare two numbers  ===
0000-            I    69       CMPAD             .MA MEMA, MEMB
0000-            I    70                         lda ]1+1
0000-            I    71                         cmp ]2+1
0000-            I    72                         bne :CA_EXIT
0000-            I    73                         lda ]1
0000-            I    74                         cmp ]2
0000-            I    75       :CA_EXIT
0000-            I    76                       .EM
0000-            I    77
0000-            I    78
0000-            I    79       ;====  Compare two numbers  ===
0000-            I    80       CMPVAL            .MA ADDR, VAL
0000-            I    81                         lda ]1
0000-            I    82                         cmp #]2
0000-            I    83                         bne :CV_EXIT
0000-            I    84                         lda ]1
0000-            I    85                         cmp /]2
0000-            I    86       :CV_EXIT
0000-            I    87                         .EM
0000-            I    88
0000-            I    89
0000-            I    90       ;==== Increment a Word
0000-            I    91       INCW              .MA VAL
0000-            I    92                         inc ]1
0000-            I    93                         bne :IW_EXIT
0000-            I    94                         inc ]1+1
0000-            I    95       :IW_EXIT
0000-            I    96                         .EM
0000-            I    97
0000-            I    98
0000-            I    99       ;==== Decrement a Word
0000-            I   100       DECW              .MA WORD
0000-            I   101                         lda ]1
0000-            I   102                         bne :DW
0000-            I   103                         dec ]1+1
0000-            I   104       :DW               dec ]1
0000-            I   105                         .EM
0000-            I   106
0000-            I   107
0000-            I   108       ;====  Add A reg to a ptr
0000-            I   109       ADDA              .MA ADDR
0000-            I   110                         clc
0000-            I   111                         adc ]1
0000-            I   112                         sta ]1
0000-            I   113                         lda #0
0000-            I   114                         adc ]1+1
0000-            I   115                         sta ]1+1
0000-            I   116                         .EM
0000-            I   117
0000-            I   118
0000-            I   119       ;====  Subtract A reg from a ptr
0000-            I   120       SUBA              .MA ADDR,VAL
0000-            I   121                         sec
0000-            I   122                         lda ]1
0000-            I   123                         sbc ]2
0000-            I   124                         sta ]2
0000-            I   125                         lda ]1+1
0000-            I   126                         sbc #0
0000-            I   127                         sta ]1+1
0000-            I   128                         .EM
0000-            I   129
0000-            I   130
0000-            I   131       ;====  Subtract two mem regs and save in 1st
0000-            I   132       SUBW              .MA MEMA,MEMB
0000-            I   133                         sec
0000-            I   134                         lda ]1
0000-            I   135                         sbc ]2
0000-            I   136                         sta ]1
0000-            I   137                         lda ]1+1
0000-            I   138                         sbc ]2+1
0000-            I   139                         sta ]1+1
0000-                 70
007F-                 71       MAXCMD            .EQ $7F               # Maximum cmdline length
0000-                 72       NO_CMD            .EQ $
0000-                 73
0000-                 74       ISHEX             .EQ $00
0001-                 75       ISDEC             .EQ $01
0000-                 76
0000-                 77       ###############################################################################
0000-                 78       #                 Zero Page Registers
0000-                 79       ###############################################################################
0000-                 80
0000-                 81       #=-=-=-=  Interrupt Vectors  =-=-=-=
0000-                 82
0020-                 83       R01_PTR           .EQ $20
0000-                 84
0020-                 85       VEC_RTABLE        .EQ R01_PTR
0000-                 86
0020-                 87       NMI_VEC0          .EQ R01_PTR           # nmi vector 0
0022-                 88       NMI_VEC1          .EQ R01_PTR+2         # nmi vector 1
0000-                 89
0024-                 90       IRQ_VEC0          .EQ R01_PTR+4         # irq vector 0
0026-                 91       IRQ_VEC1          .EQ R01_PTR+6         # irq vector 1
0028-                 92       IRQ_VEC2          .EQ R01_PTR+8         # irq vector 2
002A-                 93       IRQ_VEC3          .EQ R01_PTR+10        # irq vector 3
002C-                 94       IRQ_VEC4          .EQ R01_PTR+12        # irq vector 4
0000-                 95
002E-                 96       USER_VECTOR       .EQ R01_PTR+14
0000-                 97
0000-                 98
0000-                 99       #=-=-=-= Buffer head/tail Ptrs =-=-=-=
0000-                100
0080-                101       BIOS_PG0           .EQ $80
0000-                102
0000-                103       #=-=-=-= 2691 IRQ handler pointers and status =-=-=-=
0081-                104       UART_ICNT         .EQ BIOS_PG0+01       # Input buffer count
0082-                105       UART_IHEAD        .EQ BIOS_PG0+02       # Input buffer head pointer
0083-                106       UART_ITAIL        .EQ BIOS_PG0+03       # Input buffer tail pointer
0000-                107
0084-                108       UART_OCNT         .EQ BIOS_PG0+04       # Output buffer count
0085-                109       UART_OHEAD        .EQ BIOS_PG0+05       # Output buffer head pointer
0086-                110       UART_OTAIL        .EQ BIOS_PG0+06       # Output buffer tail pointer
0000-                111
0000-                112       #=-=-=-= Keyboard Buffer Pointers =-=-=-=
0087-                113       KYBD_ICNT         .EQ BIOS_PG0+07       # Character count in buffer
0088-                114       KYBD_IHEAD        .EQ BIOS_PG0+08       # Rx head ptr
0089-                115       KYBD_ITAIL        .EQ BIOS_PG0+09       # Rx tail ptr
0000-                116
0000-                117       #=-=-=-= Misc Stuff =-=-=-=
008A-                118       ACIA_ControlRam   .EQ BIOS_PG0+10
008B-                119       ACIA_StatusRam    .EQ BIOS_PG0+11
0000-                120
0000-                121
0000-                122
008E-                123       PGZERO_ST         .EQ BIOS_PG0+14
0000-                124
0000-                125       #=-=-=-= 16-bit C02 Monitor variables required access for BIOS =-=-=-=
008E-                126       INDEXL            .EQ PGZERO_ST         # Index for address - multiple routines
008F-                127       INDEXH            .EQ PGZERO_ST+1
0000-                128
0090-                129       MSG_PTR           .EQ PGZERO_ST+2       # Message pointer for I/O functions (2)
0000-                130
0000-                131
0000-                132       #=-=-=-= RTC stuff =-=-=-=
0092-                133       JIFFIES           .EQ PGZERO_ST+4       # 100ths of seconds
0093-                134       SECONDS           .EQ PGZERO_ST+5       # cnt of secs.
0094-                135       MINUTES           .EQ PGZERO_ST+6       # cnt of mins.
0095-                136       HOURS             .EQ PGZERO_ST+7       # cnt of hours
0096-                137       SHOWTIME          .EQ PGZERO_ST+8       # display time flag
0000-                138
0097-                139       BUFLEN            .EQ PGZERO_ST+9
0098-                140       BUFIDX            .EQ PGZERO_ST+10
0000-                141
0000-                142
0000-                143       #=-=-=-= CMD_IBUFF regs =-=-=-=
0099-                144       THISCMD           .EQ PGZERO_ST+11      # cmd index ptr
009A-                145       ARG1              .EQ PGZERO_ST+12      # ptr to 1st arg on cmd line
009B-                146       ARG2              .EQ PGZERO_ST+13      # ptr to 2nd arg on cmd line
009C-                147       ARG3              .EQ PGZERO_ST+14      # ptr to 3rd arg on cmd line
009D-                148       ARG4              .EQ PGZERO_ST+15      # ptr to 4th arg on cmd line
009E-                149       ARGCNT            .EQ PGZERO_ST+16      # how many args on cmd line
009F-                150       CMDXPTR           .EQ PGZERO_ST+17      # Holds the x ptr for the CMD_IBUFF
0000-                151
0000-                152
00A2-                153       ASCBYTE           .EQ PGZERO_ST+20      # 2 BYTEs
00A4-                154       HEX_RES           .EQ PGZERO_ST+22      # 2 BYTEs for hex results
00A6-                155       TEMP              .EQ PGZERO_ST+24      # 2 BYTEs
00A8-                156       BYTECNT           .EQ PGZERO_ST+26
00A8-                157       NUMBASE           .EQ PGZERO_ST+26
0000-                158
0000-                159
00B6-                160       SRC               .EQ PGZERO_ST+40
00B8-                161       UNTIL             .EQ PGZERO_ST+42
00BA-                162       BYTE              .EQ PGZERO_ST+44
0000-                163
0000-                164       ###############################################################################
0000-                165       #                 Buffers
0000-                166       ###############################################################################
0000-                167
0000-                168       #=-=-=-= UART =-=-=-=
0200-                169       UART_IBUF         .EQ $0200             # Console Input Buffer - 128 bytes
0280-                170       UART_OBUF         .EQ $0280             # Console Output Buffer - 128 bytes
0000-                171
0000-                172       #=-=-=-= KYBD =-=-=-=
0300-                173       KYBD_IBUF         .EQ $300              # KYBD Input Buffer - 128 bytes
0000-                174
0000-                175       #=-=-=-= CMD LINES =-=-=-=
0380-                176       CMD_IBUF          .EQ $380              # cmdline buffer
0000-                177
0400-                178       ASCIIDUMP         .EQ $400              # text formatting area for dump cmd.
0000-                179
0000-                180       ###############################################################################
0000-                181       ###############################################################################
0000-                182       #                 Start of rom - (Using only top half of 32K EEPROM)
0000-                183       ###############################################################################
8000-                184                         .OR $8000
8000-34 12           185                         .DW $1234
8002-                186
8002-                187       ###############################################################################
8002-                188       #                 Start of TLCmon
8002-                189       ###############################################################################
8002-                190
C000                191                         .NO ROM_Base
C000-                192
C000-D8              193 (  2) RESET_Ptr         cld                   # Clear decimal mode
C001-78              194 (  2)                   sei                   # and disable interrupts
C002-A2 00           195 (  2)                   ldx #$00
C004-74 00           196 (  4) pgz_lp            stz $00,x             # clr page zero
C006-CA              197 (  2)                   dex
C007-D0 FB           198 (2**)                   bne pgz_lp            # loop til done
C009-CA              199 (  2)                   dex                   # $ff - ready for stack ptr
C00A-9A              200 (  2)                   txs
C00B-                201
C00B-20 ED C1        202 (  6)                   jsr iniz_intvec       # Setup interrupt vector table
C00E-20 A0 C1        203 (  6)                   jsr inizACIA          # Setup uart
C011-                204
C011-58              205 (  2)                   cli                   # clear interrupts
C012-                206
C012-20 56 C5        207 (  6)                   jsr pr_MonHeader     # Show Header
C015-                208
C015-20 5E C5        209 (  6) cmd_loop          jsr pr_MonPrompt     # Show Prompt
C018-                210
C018-20 2C C0        211 (  6)                   jsr get_cmdline       # Read in a cmd line
C01B-F0 F8           212 (2**)                   beq cmd_loop          # If empty then retry
C01D-                213
C01D-20 84 C0        214 (  6)                   jsr parse_cmdline     # Is it a valid cmd?
C020-B0 05           215 (2**)                   bcs cmd_doit          #   Yes, then go do it.
C022-                216
C022-20 26 C5        217 (  6) cmd_bad           jsr pr_err_nocmd      #   Else, show error msg
C025-80 EE           218 (2**)                   bra cmd_loop          #   and go retry.
C027-                219
C027-20 53 C1        220 (  6) cmd_doit          jsr exec_cmd          # Execute the cmd line
C02A-                221
C02A-80 E9           222 (2**)                   bra cmd_loop          # then go get the next cmd line.
C02C-                223
C02C-                224
C02C-                225       ###############################################################################
C02C-                226       #                 Command line stuff
C02C-                227       ###############################################################################
C02C-                228
C02C-                229                         .IN cmdline/cmds_fun.inc
C02C-            I     1       #*******************************************************************************
C02C-            I     2       #                 Get a command line input
C02C-            I     3       #*******************************************************************************
C02C-            I     4
C02C-64 98       I     5 (  3) get_cmdline       stz BUFIDX            # CMDBUFF chr ptr
C02E-20 E9 C1    I     6 (  6) gecm_loop         jsr get_c             # Read a chr from STDIN
C031-C9 0D       I     7 (  2)                   cmp #CR
C033-F0 31       I     8 (2**)                   beq gecm_exit         # If it's a CR then exit
C035-            I     9
C035-C9 08       I    10 (  2)                   cmp #BS
C037-D0 0C       I    11 (2**)                   bne gecm_maxbuff      # If it's not a BackSpace go on
C039-            I    12
C039-A5 98       I    13 (  3)                   lda BUFIDX
C03B-F0 F1       I    14 (2**)                   beq gecm_loop
C03D-            I    15
C03D-C6 98       I    16 (  5)                   dec BUFIDX
C03F-20 73 C0    I    17 (  6)                   jsr back_spc          # Do the BSread 0
C042-4C 2E C0    I    18 (  3)                   jmp gecm_loop         #   and go get next chr
C045-            I    19
C045-E0 7F       I    20 (  2) gecm_maxbuff      cpx #MAXCMD
C047-D0 08       I    21 (2**)                   bne gecm_svch         # If CMDBUFF not full jump
C049-            I    22
C049-A9 07       I    23 (  2)                   lda #BELL             # Else
C04B-20 E5 C1    I    24 (  6)                   jsr put_c             #   sound the bell
C04E-4C 2E C0    I    25 (  3)                   jmp gecm_loop         #   and go get next chr
C051-            I    26
C051-A6 98       I    27 (  3) gecm_svch         ldx BUFIDX
C053-48          I    28 (  3)                   pha                   # save ch
C054-C9 61       I    29 (  2)                   cmp #$61              # Is it lowercase?
C056-90 02       I    30 (2**)                   bcc gecm_uc           # No, so go save it
C058-E9 20       I    31 (  2)                   sbc #$20              # Yes, then convert to uppercase
C05A-9D 80 03    I    32 (  5) gecm_uc           sta CMD_IBUF,x        # Save the char
C05D-68          I    33 (  4)                   pla                   # restore ch
C05E-20 E5 C1    I    34 (  6)                   jsr put_c             #   print it to STDOUT
C061-E6 98       I    35 (  5)                   inc BUFIDX
C063-4C 2E C0    I    36 (  3)                   jmp gecm_loop         #   and go get next chr
C066-            I    37
C066-20 CB C2    I    38 (  6) gecm_exit         jsr pr_CRLF          # print a CRLF
C069-A9 00       I    39 (  2)                   lda #NULL
C06B-A6 98       I    40 (  3)                   ldx BUFIDX
C06D-9D 80 03    I    41 (  5)                   sta CMD_IBUF,x        # and store a NULL in the cmd buffer
C070-E0 00       I    42 (  2)                   cpx #$00              # Set flags on exit
C072-60          I    43 (  6)                   rts
C073-            I    44
C073-            I    45
C073-            I    46       #====  Destructive BackSpace  ====
C073-20 EF C2    I    47 (  6) back_spc          jsr pr_BKSPC         # clear the ch from the scr.
C076-20 D5 C2    I    48 (  6)                   jsr pr_SPC
C079-20 EF C2    I    49 (  6)                   jsr pr_BKSPC
C07C-            I    50
C07C-A6 98       I    51 (  3)                   ldx BUFIDX
C07E-A9 00       I    52 (  2)                   lda #NULL
C080-9D 80 03    I    53 (  5)                   sta CMD_IBUF,x        # and put a null there
C083-60          I    54 (  6) bs_exit           rts
C084-            I    55
C084-            I    56
C084-            I    57       #*******************************************************************************
C084-            I    58       #                 Break cmdline up into CMD and optional ARGs
C084-            I    59       #*******************************************************************************
C084-            I    60
C084-64 9E       I    61 (  3) parse_cmdline     stz ARGCNT
C086-64 9A       I    62 (  3)                   stz ARG1
C088-64 9B       I    63 (  3)                   stz ARG2
C08A-64 9C       I    64 (  3)                   stz ARG3
C08C-64 9D       I    65 (  3)                   stz ARG4
C08E-            I    66
C08E-64 9F       I    67 (  3)                   stz CMDXPTR
C090-            I    68
C090-20 C1 C0    I    69 (  6)                   jsr get_cmd           # Is there a valid CMD present?
C093-90 28       I    70 (2**)                   bcc pacm_bexit        #   No, go to err exit
C095-            I    71
C095-20 F8 C0    I    72 (  6)                   jsr get_next_arg_ptr  # Is there an ARG1?
C098-90 1F       I    73 (2**)                   bcc pacm_gexit        #   No, go to clean exit
C09A-            I    74
C09A-86 9A       I    75 (  3)                   stx ARG1              #   Yes, then store index
C09C-E6 9E       I    76 (  5)                   inc ARGCNT            #   and increment arg counter
C09E-            I    77
C09E-20 F8 C0    I    78 (  6)                   jsr get_next_arg_ptr  # Is there an ARG2?
C0A1-90 16       I    79 (2**)                   bcc pacm_gexit        #   No, go to clean exit
C0A3-            I    80
C0A3-86 9B       I    81 (  3)                   stx ARG2              #   Yes, then store index
C0A5-E6 9E       I    82 (  5)                   inc ARGCNT            #   and increment arg counter
C0A7-            I    83
C0A7-20 F8 C0    I    84 (  6)                   jsr get_next_arg_ptr  # Is ther an ARG3?
C0AA-90 0D       I    85 (2**)                   bcc pacm_gexit        #   No, go to clean exit
C0AC-            I    86
C0AC-86 9C       I    87 (  3)                   stx ARG3              #   Yes, then store index
C0AE-E6 9E       I    88 (  5)                   inc ARGCNT            #   and increment arg counter
C0B0-            I    89
C0B0-20 F8 C0    I    90 (  6)                   jsr get_next_arg_ptr  # Is there an ARG4?
C0B3-90 04       I    91 (2**)                   bcc pacm_gexit        #   No, go to clean exit
C0B5-            I    92
C0B5-86 9D       I    93 (  3)                   stx ARG4              #   Yes, then store index
C0B7-E6 9E       I    94 (  5)                   inc ARGCNT            #   and increment arg counter
C0B9-A5 99       I    95 (  3) pacm_gexit        lda THISCMD           # Clean exit
C0BB-38          I    96 (  2)                   sec                   # Set Carry flag
C0BC-60          I    97 (  6)                   rts                   # and exit
C0BD-            I    98
C0BD-A5 99       I    99 (  3) pacm_bexit        lda THISCMD           # Error exit
C0BF-18          I   100 (  2)                   clc                   # Clear Carry flag
C0C0-60          I   101 (  6)                   rts                   # and exit
C0C1-            I   102
C0C1-            I   103
C0C1-            I   104
C0C1-            I   105       #*******************************************************************************
C0C1-            I   106       #                 Is there a cmd present?
C0C1-            I   107       #                   Success:    sec = Yes, y = ptr
C0C1-            I   108       #                   Faliure:    clc = No, y = NO_CMD
C0C1-            I   109       #*******************************************************************************
C0C1-            I   110
C0C1-64 99       I   111 (  3) get_cmd           stz THISCMD           # Iniz cmd ptr
C0C3-A0 00       I   112 (  2)                   ldy #$00              # Iniz Cmd table ptr
C0C5-A6 9F       I   113 (  3)                   ldx CMDXPTR           # Get start of cmd pos.
C0C7-BD 80 03    I   114 ( 4*) gc_loop           lda CMD_IBUF,x        # Get cmd line chr
C0CA-F0 0D       I   115 (2**)                   beq gc_test_table     # found a NULL  - exit cmp loop
C0CC-            I   116
C0CC-C9 20       I   117 (  2)                   cmp #SPC              # Is it a space?
C0CE-F0 09       I   118 (2**)                   beq gc_test_table     #   Yes, go exit cmp loop
C0D0-            I   119
C0D0-D9 69 C6    I   120 ( 4*)                   cmp VALID_CMDS,y      # is it in curr cmd word?
C0D3-D0 0D       I   121 (2**)                   bne gc_next_cmd       #   No, go find next cmd word
C0D5-            I   122
C0D5-E8          I   123 (  2)                   inx                   #   inc ptrs
C0D6-C8          I   124 (  2)                   iny
C0D7-80 EE       I   125 (2**)                   bra gc_loop           #   and go test next chr
C0D9-B9 69 C6    I   126 ( 4*) gc_test_table     lda VALID_CMDS,y      # Is it end of cmd?
C0DC-D0 04       I   127 (2**)                   bne gc_next_cmd       #   No, go find next cmd word
C0DE-            I   128
C0DE-A4 99       I   129 (  3)                   ldy THISCMD
C0E0-38          I   130 (  2)                   sec                   # Found exit
C0E1-60          I   131 (  6)                   rts
C0E2-            I   132
C0E2-A6 9F       I   133 (  3) gc_next_cmd       ldx CMDXPTR           # Reset cmd-ptr
C0E4-E6 99       I   134 (  5)                   inc THISCMD           # inc to nxt cmd
C0E6-A5 99       I   135 (  3)                   lda THISCMD           # Get cmd ptr
C0E8-            I   136                         >MULTAx8               #   mult by 8 - each cmd is max 7 chr long + NULL
C0E8-18          IM    1 (  2)                   clc
C0E9-0A          IM    2 (  2)                   asl a
C0EA-0A          IM    3 (  2)                   asl a
C0EB-0A          IM    4 (  2)                   asl a
C0EC-A8          I   137 (  2)                   tay                   #   transfer to y index
C0ED-B9 69 C6    I   138 ( 4*)                   lda VALID_CMDS,y      # Is it end of VALID_CMDS table?
C0F0-D0 D5       I   139 (2**)                   bne gc_loop           #   No, so go compare next cmd
C0F2-            I   140
C0F2-A0 00       I   141 (  2) gc_bad_exit       ldy #NO_CMD           # Cmd not Found exit
C0F4-84 99       I   142 (  3)                   sty THISCMD
C0F6-18          I   143 (  2)                   clc
C0F7-60          I   144 (  6)                   rts
C0F8-            I   145
C0F8-            I   146
C0F8-            I   147       #*******************************************************************************
C0F8-            I   148       #                 Get a possible ARG ptr from CMDLINE
C0F8-            I   149       #                 On Exit:  Success:    sec
C0F8-            I   150       #                           Failure:    clc
C0F8-            I   151       #*******************************************************************************
C0F8-            I   152
C0F8-BD 80 03    I   153 ( 4*) get_next_arg_ptr  lda CMD_IBUF,x        # Get cmd line chr
C0FB-F0 21       I   154 (2**)                   beq gnap_bexit        # It's a NULL - EOL go exit
C0FD-            I   155
C0FD-20 22 C1    I   156 (  6)                   jsr find_next_SPC
C100-90 1C       I   157 (2**)                   bcc gnap_bexit
C102-            I   158
C102-BD 80 03    I   159 ( 4*) gnap_loop         lda CMD_IBUF,x        # Get cmd line chr
C105-20 BB C2    I   160 (  6)                   jsr is_seperator      # Is it a SPC, COMMA or COLON?
C108-90 03       I   161 (2**)                   bcc gnap_isalpha      #   No, then go chk if it is AlphaNumeric?
C10A-            I   162
C10A-E8          I   163 (  2)                   inx
C10B-80 F5       I   164 (2**)                   bra gnap_loop         #   Yes, then skip to next ch
C10D-20 6C C2    I   165 (  6) gnap_isalpha      jsr is_alphanumeric   # Is it AlphaNumeric (A-Z, a-z, 0-9)?
C110-B0 0E       I   166 (2**)                   bcs gnap_gexit        #   Yes, found 1st ch of ARG, go good exit
C112-            I   167
C112-C9 23       I   168 (  2) gnap_ishash       cmp #HASH             # Is it a # ?
C114-F0 0A       I   169 (2**)                   beq gnap_gexit        #   Yes, go good exit
C116-            I   170
C116-C9 24       I   171 (  2)                   cmp #DOLLAR           # Is it a $ ?
C118-F0 06       I   172 (2**)                   beq gnap_gexit        #   Yes, go good exit
C11A-            I   173
C11A-C9 3F       I   174 (  2)                   cmp #'?'              # Is it a ? ?
C11C-F0 02       I   175 (2**)                   beq gnap_gexit        #   Yes, go good exit
C11E-            I   176
C11E-            I   177
C11E-18          I   178 (  2) gnap_bexit        clc                   # Anything that get's to here is an illegal ch
C11F-60          I   179 (  6)                   rts
C120-            I   180
C120-38          I   181 (  2) gnap_gexit        sec                   # Good exit, ARG found
C121-60          I   182 (  6)                   rts
C122-            I   183
C122-            I   184
C122-BD 80 03    I   185 ( 4*) find_next_SPC     lda CMD_IBUF,x                                                ; Get cmd line chr
C125-F0 08       I   186 (2**)                   beq fis_bexit                                         ; It's a NULL - EOL go exit
C127-            I   187
C127-20 BB C2    I   188 (  6)                   jsr is_seperator
C12A-B0 05       I   189 (2**)                   bcs fis_gexit
C12C-            I   190
C12C-E8          I   191 (  2)                   inx
C12D-80 F3       I   192 (2**)                   bra find_next_SPC
C12F-18          I   193 (  2) fis_bexit         clc
C130-60          I   194 (  6)                   rts
C131-            I   195
C131-38          I   196 (  2) fis_gexit         sec
C132-60          I   197 (  6)                   rts
C133-            I   198
C133-            I   199
C133-            I   200
C133-            I   201
C133-            I   202
C133-            I   203       #*******************************************************************************
C133-            I   204       #                 Get SRC addr
C133-            I   205       #                 sec=Yes, clc=No
C133-            I   206       #*******************************************************************************
C133-            I   207
C133-20 9B C5    I   208 (  6) get_SRC_addr      jsr get_ASC_number    # Attempt to get a number
C136-B0 01       I   209 (2**)                   bcs gsa_mvnum         #   Yes, go move it
C138-            I   210
C138-60          I   211 (  6)                   rts                   #   No, exit
C139-            I   212
C139-            I   213       gsa_mvnum         >CPYW HEX_RES,SRC     # Copy to SRC
C139-A5 A4       IM    1 (  3)                   lda HEX_RES
C13B-85 B6       IM    2 (  3)                   sta SRC
C13D-A5 A5       IM    3 (  3)                   lda HEX_RES+1
C13F-85 B7       IM    4 (  3)                   sta SRC+1
C141-38          I   214 (  2)                   sec
C142-60          I   215 (  6)                   rts
C143-            I   216
C143-            I   217
C143-            I   218       #*******************************************************************************
C143-            I   219       #                 Get UNTIL addr
C143-            I   220       #                 sec=Yes, clc=No
C143-            I   221       #*******************************************************************************
C143-            I   222
C143-20 9B C5    I   223 (  6) get_UNTIL_addr    jsr get_ASC_number    # Attempt to get a number
C146-B0 01       I   224 (2**)                   bcs gua_mvnum         #   Yes, go move it
C148-            I   225
C148-60          I   226 (  6)                   rts                   #   No, exit
C149-            I   227
C149-            I   228       gua_mvnum         >CPYW HEX_RES,UNTIL   # Copy to UNTIL
C149-A5 A4       IM    1 (  3)                   lda HEX_RES
C14B-85 B8       IM    2 (  3)                   sta UNTIL
C14D-A5 A5       IM    3 (  3)                   lda HEX_RES+1
C14F-85 B9       IM    4 (  3)                   sta UNTIL+1
C151-38          I   229 (  2)                   sec
C152-60          I   230 (  6)                   rts
C153-            I   231
C153-            I   232
C153-            I   233       #*******************************************************************************
C153-            I   234       #                 Execute a command from the jumptable
C153-            I   235       #*******************************************************************************
C153-            I   236
C153-A5 99       I   237 (  3) exec_cmd          lda THISCMD           # Get the cmd index
C155-18          I   238 (  2)                   clc
C156-0A          I   239 (  2)                   asl a                 # and double it
C157-AA          I   240 (  2)                   tax
C158-7C C3 C6    I   241 (  6)                   jmp (CMD_JUMP_TABLE,x)
C15B-            I   242
C15B-            I   243
C15B-            I   244
C15B-            I   245
C15B-A2 00       I   246 (  2) prline            ldx #0
C15D-A4 98       I   247 (  3)                   ldy BUFIDX
C15F-BD 80 03    I   248 ( 4*) prllp             lda CMD_IBUF,x
C162-20 E5 C1    I   249 (  6)                   jsr put_c
C165-E8          I   250 (  2)                   inx
C166-88          I   251 (  2)                   dey
C167-D0 F6       I   252 (2**)                   bne prllp
C169-60          I   253 (  6)                   rts
C16A-            I   254
C16A-A2 00       I   255 (  2) prasline          ldx #0
C16C-A0 14       I   256 (  2)                   ldy #20
C16E-BD 80 03    I   257 ( 4*) praslp            lda CMD_IBUF,x
C171-20 7C C1    I   258 (  6)                   jsr prbyte
C174-20 D5 C2    I   259 (  6)                   jsr pr_SPC
C177-E8          I   260 (  2)                   inx
C178-88          I   261 (  2)                   dey
C179-D0 F3       I   262 (2**)                   bne praslp
C17B-60          I   263 (  6)                   rts
C17C-                230
C17C-                231
C17C-                232                         .IN misc/ch_fun.inc
C17C-            I     1       #*******************************************************************************
C17C-            I     2       #                 Print a byte as two Ascii characters
C17C-            I     3       #*******************************************************************************
C17C-48          I     4 (  3) prbyte            pha
C17D-5A          I     5 (  3)                   phy
C17E-20 8B C1    I     6 (  6) prbyt2            jsr bin2asc
C181-20 E5 C1    I     7 (  6)                   jsr put_c
C184-98          I     8 (  2)                   tya
C185-20 E5 C1    I     9 (  6)                   jsr put_c
C188-7A          I    10 (  4)                   ply
C189-68          I    11 (  4)                   pla
C18A-60          I    12 (  6)                   rts
C18B-            I    13
C18B-            I    14       #*******************************************************************************
C18B-            I    15       #                 Convert a single binary digit (0-9,A-F) to an Ascii character
C18B-            I    16       #*******************************************************************************
C18B-48          I    17 (  3) bin2asc           pha
C18C-29 0F       I    18 (  2)                   and #$0F
C18E-20 97 C1    I    19 (  6)                   jsr con_ascii
C191-A8          I    20 (  2)                   tay
C192-68          I    21 (  4)                   pla
C193-4A          I    22 (  2)                   lsr a
C194-4A          I    23 (  2)                   lsr a
C195-4A          I    24 (  2)                   lsr a
C196-4A          I    25 (  2)                   lsr a
C197-            I    26
C197-C9 0A       I    27 (  2) con_ascii         cmp #$0A
C199-90 02       I    28 (2**)                   bcc ascok
C19B-69 06       I    29 (  2)                   adc #$06
C19D-69 30       I    30 (  2) ascok             adc #$30
C19F-60          I    31 (  6)                   rts
C1A0-                233
C1A0-                234
C1A0-                235       ###############################################################################
C1A0-                236       #                 ACIA stuff
C1A0-                237       ###############################################################################
C1A0-                238
C1A0-                239                         .IN devs/ACIA1_fun.inc
C1A0-            I     1       ###############################################################################
C1A0-            I     2       #                               ACIA stuff
C1A0-            I     3       ###############################################################################
C1A0-            I     4
C1A0-A9 03       I     5 (  2) inizACIA          lda #ACIA_RESET       # Reset ACIA
C1A2-85 8A       I     6 (  3)                   sta ACIA_ControlRam   # Always save a copy of the register in RAM
C1A4-8D 00 A2    I     7 (  4)                   sta ACIA_Control      # Set RAM copy first because hardware generates IRQs
C1A7-A9 15       I     8 (  2)                   lda #ACIA_INIT        # Set N-8-1, Div 16 (overwrite old control byte)
C1A9-85 8A       I     9 (  3)                   sta ACIA_ControlRam
C1AB-8D 00 A2    I    10 (  4)                   sta ACIA_Control
C1AE-A5 8A       I    11 (  3)                   lda ACIA_ControlRam   # Always load the control byte image from RAM
C1B0-09 80       I    12 (  2)                   ora #ACIA_RXI_EN      # Also enable Rx interrupt (no Tx IRQ at this time)
C1B2-85 8A       I    13 (  3)                   sta ACIA_ControlRam
C1B4-8D 00 A2    I    14 (  4)                   sta ACIA_Control
C1B7-60          I    15 (  6)                   rts
C1B8-            I    16
C1B8-            I    17
C1B8-            I    18       #------------------------------------------------------------------------------
C1B8-            I    19       # Put a character to output (character in A)
C1B8-            I    20       #------------------------------------------------------------------------------
C1B8-            I    21
C1B8-5A          I    22 (  3) ACIA1_put_c       phy
C1B9-A4 84       I    23 (  3) OUTCH             ldy UART_OCNT
C1BB-30 FC       I    24 (2**)                   bmi OUTCH
C1BD-            I    25
C1BD-A4 86       I    26 (  3)                   ldy UART_OTAIL
C1BF-99 80 02    I    27 (  5)                   sta UART_OBUF,y
C1C2-E6 86       I    28 (  5)                   inc UART_OTAIL
C1C4-77 86       I    29 (  5)                   rmb7 UART_OTAIL
C1C6-E6 84       I    30 (  5)                   inc UART_OCNT
C1C8-            I    31
C1C8-A5 8A       I    32 (  3)                   lda ACIA_ControlRam   # may interrupt immediately if tx isn't busy
C1CA-09 20       I    33 (  2)                   ora #ACIA_TXI_EN      # Use "or"  to set the bits for the transmit IRQ
C1CC-85 8A       I    34 (  3)                   sta ACIA_ControlRam
C1CE-8D 00 A2    I    35 (  4)                   sta ACIA_Control
C1D1-            I    36
C1D1-7A          I    37 (  4)                   ply
C1D2-60          I    38 (  6)                   rts
C1D3-            I    39       #-------------------------------------------------------------------------------
C1D3-            I    40       # Wait until at least one character is available in the input queue, and return
C1D3-            I    41       # the first character in A
C1D3-            I    42       #-------------------------------------------------------------------------------
C1D3-            I    43
C1D3-A5 81       I    44 (  3) ACIA1_get_c       lda UART_ICNT
C1D5-F0 FC       I    45 (2**)                   beq ACIA1_get_c       # Loop until atleast 1 ch in buffer
C1D7-            I    46
C1D7-5A          I    47 (  3)                   phy
C1D8-A4 82       I    48 (  3)                   ldy UART_IHEAD        # Get the buffer head pointer
C1DA-B9 00 02    I    49 ( 4*)                   lda UART_IBUF,Y       # Get the character from the buffer
C1DD-E6 82       I    50 (  5)                   inc UART_IHEAD        # Increment head pointer
C1DF-77 82       I    51 (  5)                   rmb7 UART_IHEAD       # Strip off bit 7, 128 bytes only
C1E1-C6 81       I    52 (  5)                   DEC UART_ICNT         # Decrement the buffer count
C1E3-            I    53
C1E3-7A          I    54 (  4)                   ply                   # Restore Y Reg
C1E4-60          I    55 (  6)                   rts                   # Return to caller with character in A Reg
C1E5-                240
C1E5-                241
C1E5-                242       #-------------------------------------------------------------------------------
C1E5-                243       # Send a character to output (character in A)
C1E5-                244       #-------------------------------------------------------------------------------
C1E5-                245
C1E5-20 B8 C1        246 (  6) put_c             jsr ACIA1_put_c
C1E8-60              247 (  6)                   rts
C1E9-                248
C1E9-                249
C1E9-                250       #-------------------------------------------------------------------------------
C1E9-                251       # Wait until at least one character is available in the input queue, and return
C1E9-                252       # the first character in A
C1E9-                253       #-------------------------------------------------------------------------------
C1E9-                254
C1E9-20 D3 C1        255 (  6) get_c             jsr ACIA1_get_c
C1EC-60              256 (  6)                   rts
C1ED-                257
C1ED-                258
C1ED-                259       #                  .IN misc/output_fun.inc
C1ED-                260
C1ED-                261       ###############################################################################
C1ED-                262       #               Interrupt stuff
C1ED-                263       ###############################################################################
C1ED-                264
C1ED-                265                         .IN misc/interrupt_fun.inc
C1ED-            I     1       #==============================================================================
C1ED-            I     2       #                 Iniz the Interrupt vector table
C1ED-            I     3       #==============================================================================
C1ED-            I     4
C1ED-A0 00       I     5 (  2) iniz_intvec       ldy   #$00
C1EF-B9 0F C2    I     6 ( 4*) inin_loop         lda   VEC_ETABLE,y      # Get Vector table data
C1F2-99 20 00    I     7 (  5)                   sta   VEC_RTABLE,y      # Store in Soft Vector jmp location
C1F5-C8          I     8 (  2)                   iny                   # Increment index
C1F6-C0 10       I     9 (  2)                   cpy #16
C1F8-D0 F5       I    10 (2**)                   bne   inin_loop         # Loop back till done
C1FA-60          I    11 (  6)                   rts                   # Return to caller
C1FB-            I    12
C1FB-            I    13       #==============================================================================
C1FB-            I    14       #                 IRQ Entry point and exit function
C1FB-            I    15       #==============================================================================
C1FB-            I    16
C1FB-            I    17       #=-=-=-=  This is the ROM start for the IRQ handler  =-=-=-=
C1FB-            I    18
C1FB-48          I    19 (  3) IRQ_vector        pha                   # Save A Reg (3)
C1FC-DA          I    20 (  3)                   phx                   # Save X Reg (3)
C1FD-5A          I    21 (  3)                   phy                   # Save Y Reg (3)
C1FE-6C 24 00    I    22 (  6)                   jmp   (IRQ_VEC0)        # Jump to Soft vectored IRQ Handler (5)
C201-            I    23
C201-            I    24
C201-            I    25       #=-=-=-=  This is the standard return for the IRQ handler  =-=-=-=
C201-            I    26
C201-7A          I    27 (  4) IRQ_exit          ply                   # Restore Y Reg (4)
C202-FA          I    28 (  4)                   plx                   # Restore X Reg (4)
C203-68          I    29 (  4)                   pla                   # Restore A Reg (4)
C204-40          I    30 (  6)                   rti                   # Return from IRQ routine (6)
C205-            I    31
C205-            I    32       #==============================================================================
C205-            I    33       #                 NMI Entry point and exit function
C205-            I    34       #==============================================================================
C205-            I    35
C205-48          I    36 (  3) NMI_vector        pha                   # Save A Reg (3)
C206-DA          I    37 (  3)                   phx                   # Save X Reg (3)
C207-5A          I    38 (  3)                   phy                   # Save Y Reg (3)
C208-6C 20 00    I    39 (  6)                   jmp   (NMI_VEC0)        # Jump to Soft vectored NMI Handler (5)
C20B-            I    40
C20B-            I    41
C20B-7A          I    42 (  4) NMI_exit          ply                   # Restore Y Reg (4)
C20C-FA          I    43 (  4)                   plx                   # Restore X Reg (4)
C20D-68          I    44 (  4)                   pla                   # Restore A Reg (4)
C20E-40          I    45 (  6)                   rti                   # Return from NMI routine (6)
C20F-                266
C20F-                267
C20F-                268                         .IN misc/interrupt_table.inc
C20F-            I     1       #=====================================================================
C20F-            I     2       #  Vector table data for default ROM handlers
C20F-            I     3       #=====================================================================
C20F-            I     4
C20F-05 C2       I     5       VEC_ETABLE        .DW NMI_vector        # NMI Location in ROM
C211-0B C2       I     6                         .DW NMI_exit          # NMI return handler in ROM
C213-            I     7
C213-1F C2       I     8                         .DW ACIA_isr          # UART isr Location in ROM
C215-            I     9       #                  .DW VIA1_isr          # RTC isr Location in ROM
C215-01 C2       I    10                         .DW IRQ_exit          # IRQ return handler in ROM
C217-01 C2       I    11                         .DW IRQ_exit          # IRQ return handler in ROM
C219-01 C2       I    12                         .DW IRQ_exit          # IRQ return handler in ROM
C21B-01 C2       I    13                         .DW IRQ_exit          # IRQ return handler in ROM
C21D-01 C2       I    14                         .DW IRQ_exit          # IRQ return handler in ROM
C21F-                269
C21F-                270
C21F-                271       ###############################################################################
C21F-                272       #               Device ISR stuff
C21F-                273       ###############################################################################
C21F-                274
C21F-                275                         .IN devs/ACIA1_int_fun.inc
C21F-            I     1       #==============================================================================
C21F-            I     2       #                 6850 Interrupt Service Routine
C21F-            I     3       #==============================================================================
C21F-            I     4
C21F-AD 00 A2    I     5 (  4) ACIA_isr          lda ACIA_Status       # Get status from 6850
C222-10 12       I     6 (2**)                   bpl ai_next_irq       # No interrupt, so go try the next device
C224-            I     7
C224-85 8B       I     8 (  3)                   sta ACIA_StatusRam    # Store in MOS variable in RAM
C226-            I     9
C226-A9 01       I    10 (  2)                   lda #ACIA_RDRF
C228-24 8B       I    11 (  3)                   bit ACIA_StatusRam    # Check receiver full flag
C22A-F0 02       I    12 (2**)                   beq CheckXmt          # Branch to next check if flag not set
C22C-            I    13
C22C-80 2A       I    14 (2**)                   bra ACIA_isr_rx       # Receive character into buffer
C22E-            I    15
C22E-A9 02       I    16 (  2) CheckXmt          lda #ACIA_TDRE
C230-24 8B       I    17 (  3)                   bit ACIA_StatusRam    # Check transmitter empty flag
C232-F0 02       I    18 (2**)                   beq ai_next_irq       # Branch to next check if flag not set
C234-            I    19
C234-80 03       I    20 (2**)                   bra ACIA_isr_tx       # Handle transmitter
C236-            I    21
C236-6C 26 00    I    22 (  6) ai_next_irq       jmp (IRQ_VEC1)
C239-            I    23
C239-            I    24
C239-            I    25       #==============================================================================
C239-            I    26       #                 ACIA Transmit ISR
C239-            I    27       #==============================================================================
C239-            I    28
C239-A5 84       I    29 (  3) ACIA_isr_tx       lda UART_OCNT
C23B-F0 10       I    30 (2**)                   beq actr_exit
C23D-            I    31
C23D-A4 85       I    32 (  3)                   ldy UART_OHEAD
C23F-B9 80 02    I    33 ( 4*)                   lda UART_OBUF,y
C242-8D 01 A2    I    34 (  4)                   sta ACIA_Tx
C245-E6 85       I    35 (  5)                   inc UART_OHEAD
C247-77 85       I    36 (  5)                   rmb7 UART_OHEAD
C249-C6 84       I    37 (  5)                   dec UART_OCNT
C24B-80 E9       I    38 (2**)                   bra ai_next_irq
C24D-            I    39
C24D-A5 8A       I    40 (  3) actr_exit         lda ACIA_ControlRam   # No more chars in the buf turn off the tx-empty IRQ.
C24F-29 9F       I    41 (  2)                   and #ACIA_TXI_DS      # Use "and" to clear the bits for the transmit IRQ
C251-85 8A       I    42 (  3)                   sta ACIA_ControlRam
C253-8D 00 A2    I    43 (  4)                   sta ACIA_Control
C256-80 DE       I    44 (2**)                   bra ai_next_irq
C258-            I    45
C258-            I    46
C258-            I    47       #==============================================================================
C258-            I    48       #                 ACIA Receive ISR
C258-            I    49       #==============================================================================
C258-            I    50
C258-A4 81       I    51 (  3) ACIA_isr_rx       ldy UART_ICNT
C25A-30 DA       I    52 (2**)                   bmi ai_next_irq
C25C-AD 01 A2    I    53 (  4)                   lda ACIA_Rx
C25F-            I    54
C25F-A4 83       I    55 (  3)                   ldy UART_ITAIL
C261-99 00 02    I    56 (  5)                   sta UART_IBUF,y
C264-E6 83       I    57 (  5)                   inc UART_ITAIL
C266-77 83       I    58 (  5)                   rmb7 UART_ITAIL
C268-E6 81       I    59 (  5)                   inc UART_ICNT
C26A-            I    60
C26A-80 CA       I    61 (2**)                   bra ai_next_irq
C26C-                276
C26C-                277
C26C-                278
C26C-                279       ###############################################################################
C26C-                280       #               Character tests
C26C-                281       ###############################################################################
C26C-                282
C26C-                283                       .IN misc/ch_tests.inc
C26C-            I     1       #*******************************************************************************
C26C-            I     2       #                 Is this ch a number or a letter?
C26C-            I     3       #                 On Exit: clc=No, sec=Yes
C26C-            I     4       #*******************************************************************************
C26C-            I     5
C26C-20 98 C2    I     6 (  6) is_alphanumeric   jsr is_numeric
C26F-90 01       I     7 (2**)                   bcc isalet
C271-60          I     8 (  6)                   rts                   # Exit if NOT numeric
C272-20 76 C2    I     9 (  6) isalet            jsr is_alpha
C275-60          I    10 (  6)                   rts
C276-            I    11
C276-            I    12
C276-            I    13       #*******************************************************************************
C276-            I    14       #                 Is this ch a letter?
C276-            I    15       #                 On Exit: clc=No, sec=Yes
C276-            I    16       #*******************************************************************************
C276-            I    17
C276-20 80 C2    I    18 (  6) is_alpha          jsr is_lowercase
C279-90 01       I    19 (2**)                   bcc isalp
C27B-60          I    20 (  6)                   rts                   # Exit if NOT lowercase
C27C-            I    21
C27C-20 8C C2    I    22 (  6) isalp             jsr is_uppercase
C27F-60          I    23 (  6)                   rts
C280-            I    24
C280-            I    25
C280-            I    26       #*******************************************************************************
C280-            I    27       #                 Is this ch lowercase?
C280-            I    28       #                 On Exit: clc=No, sec=Yes
C280-            I    29       #*******************************************************************************
C280-            I    30
C280-C9 61       I    31 (  2) is_lowercase      cmp #'a'
C282-90 06       I    32 (2**)                   bcc islcbad           # < 'a'
C284-C9 7B       I    33 (  2)                   cmp #'z'+1
C286-B0 02       I    34 (2**)                   bcs islcbad           # >= 'z'
C288-38          I    35 (  2)                   sec
C289-60          I    36 (  6)                   rts
C28A-            I    37
C28A-18          I    38 (  2) islcbad           clc
C28B-60          I    39 (  6)                   rts
C28C-            I    40
C28C-            I    41
C28C-            I    42       #*******************************************************************************
C28C-            I    43       #                 Is this ch uppercase?
C28C-            I    44       #                 On Exit: clc=No, sec=Yes
C28C-            I    45       #*******************************************************************************
C28C-            I    46
C28C-C9 41       I    47 (  2) is_uppercase      cmp #'A'
C28E-90 06       I    48 (2**)                   bcc isucbad           # < 'A'
C290-C9 5B       I    49 (  2)                   cmp #'Z'+1
C292-B0 02       I    50 (2**)                   bcs isucbad           # >= 'Z'
C294-38          I    51 (  2)                   sec
C295-60          I    52 (  6)                   rts
C296-            I    53
C296-18          I    54 (  2) isucbad           clc
C297-60          I    55 (  6)                   rts
C298-            I    56
C298-            I    57
C298-            I    58       #*******************************************************************************
C298-            I    59       #                 Is this ch a number?
C298-            I    60       #                 On Exit: clc=No, sec=Yes
C298-            I    61       #*******************************************************************************
C298-            I    62
C298-C9 30       I    63 (  2) is_numeric        cmp #'0'
C29A-90 04       I    64 (2**)                   bcc isnu_bexit                                        ; < '0'
C29C-C9 3A       I    65 (  2)                   cmp #'9'+1
C29E-90 02       I    66 (2**)                   bcc isnu_gexit                                        ; <= '9'
C2A0-18          I    67 (  2) isnu_bexit        clc
C2A1-60          I    68 (  6)                   rts
C2A2-            I    69
C2A2-38          I    70 (  2) isnu_gexit        sec
C2A3-60          I    71 (  6)                   rts
C2A4-            I    72
C2A4-            I    73
C2A4-            I    74       #*******************************************************************************
C2A4-            I    75       #                 Is this ch hexadecimal?
C2A4-            I    76       #                 On Exit: clc=No, sec=Yes
C2A4-            I    77       #*******************************************************************************
C2A4-            I    78
C2A4-20 98 C2    I    79 (  6) is_hexadecimal    jsr is_numeric
C2A7-B0 03       I    80 (2**)                   bcs ihd_gexit
C2A9-            I    81
C2A9-20 AD C2    I    82 (  6)                   jsr is_hexaf
C2AC-60          I    83 (  6) ihd_gexit         rts
C2AD-            I    84
C2AD-            I    85
C2AD-            I    86       #*******************************************************************************
C2AD-            I    87       #                 Is this ch hex a-f?
C2AD-            I    88       #                 On Exit: clc=No, sec=Yes
C2AD-            I    89       #*******************************************************************************
C2AD-            I    90
C2AD-09 20       I    91 (  2) is_hexaf          ora #$20              # convert to lowercase
C2AF-C9 61       I    92 (  2)                   cmp #'a'
C2B1-90 04       I    93 (2**)                   bcc ishx_bexit        # < 'a'
C2B3-            I    94
C2B3-C9 67       I    95 (  2)                   cmp #'f'+1
C2B5-90 02       I    96 (2**)                   bcc ishx_gexit        # <= 'f'
C2B7-            I    97
C2B7-18          I    98 (  2) ishx_bexit        clc
C2B8-60          I    99 (  6)                   rts
C2B9-            I   100
C2B9-38          I   101 (  2) ishx_gexit        sec
C2BA-60          I   102 (  6)                   rts
C2BB-            I   103
C2BB-            I   104
C2BB-            I   105       #*******************************************************************************
C2BB-            I   106       #                 Is this ch a space, comma or colon
C2BB-            I   107       #                 On Exit: clc=No, sec=Yes
C2BB-            I   108       #*******************************************************************************
C2BB-            I   109
C2BB-C9 20       I   110 (  2) is_seperator      cmp #SPC
C2BD-F0 0A       I   111 (2**)                   beq isse_gexit
C2BF-            I   112
C2BF-C9 2C       I   113 (  2)                   cmp #COMMA
C2C1-F0 06       I   114 (2**)                   beq isse_gexit
C2C3-            I   115
C2C3-C9 3A       I   116 (  2)                   cmp #COLON
C2C5-F0 02       I   117 (2**)                   beq isse_gexit
C2C7-            I   118
C2C7-18          I   119 (  2) isse_bexit        clc
C2C8-60          I   120 (  6)                   rts
C2C9-            I   121
C2C9-38          I   122 (  2) isse_gexit        sec
C2CA-60          I   123 (  6)                   rts
C2CB-                284
C2CB-                285
C2CB-                286       ###############################################################################
C2CB-                287       #                 Print various characters
C2CB-                288       ###############################################################################
C2CB-                289
C2CB-A9 0D           290 (  2) pr_CRLF           lda #CR
C2CD-20 E5 C1        291 (  6)                   jsr put_c
C2D0-A9 0A           292 (  2)                   lda #LF
C2D2-4C E5 C1        293 (  3)                   jmp put_c
C2D5-                294
C2D5-                295
C2D5-A9 20           296 (  2) pr_SPC            lda #SPC
C2D7-4C E5 C1        297 (  3)                   jmp put_c
C2DA-                298
C2DA-                299
C2DA-                300       #====  Print X Spaces  ====
C2DA-A9 20           301 (  2) pr_XSPC           lda #SPC
C2DC-20 E5 C1        302 (  6)                   jsr put_c
C2DF-CA              303 (  2)                   dex
C2E0-D0 F8           304 (2**)                   bne pr_XSPC
C2E2-                305
C2E2-60              306 (  6)                   rts
C2E3-                307
C2E3-                308
C2E3-A9 2A           309 (  2) pr_STAR           lda #STAR
C2E5-4C E5 C1        310 (  3)                   jmp put_c
C2E8-                311
C2E8-                312
C2E8-                313       pr_IBUF           >CPYMSPTR CMD_IBUF
C2E8-A9 80        M    1 (  2)                   lda #CMD_IBUF
C2EA-A0 03        M    2 (  2)                   ldy /CMD_IBUF
C2EC-4C FD C4        314 (  3)                   jmp put_str
C2EF-                315
C2EF-                316
C2EF-A9 08           317 (  2) pr_BKSPC          lda #BS
C2F1-4C E5 C1        318 (  3)                   jmp put_c
C2F4-                319
C2F4-                320
C2F4-A9 3D           321 (  2) pr_EQUALS         lda #EQUALS
C2F6-4C E5 C1        322 (  3)                   jmp put_c
C2F9-                323
C2F9-                324
C2F9-A9 24           325 (  2) pr_DOLLAR         lda #DOLLAR
C2FB-4C E5 C1        326 (  3)                   jmp put_c
C2FE-                327
C2FE-                328
C2FE-A9 3A           329 (  2) pr_COLON          lda #COLON
C300-4C E5 C1        330 (  3)                   jmp put_c
C303-                331
C303-                332
C303-                333
C303-                334       # Print system messages stuff
C303-                335
C303-                336                         .IN misc/sys_msgs.inc
C303-            I     1       #*******************************************************************************
C303-            I     2       #                 Error Messages
C303-            I     3       #*******************************************************************************
C303-            I     4
C303-45 72 72 3A 
     20 00       I     5       ERR_LEADER        .DB "Err: ", NULL
C309-            I     6
C309-48 75 68 3F 
     3F 20 44 6F 
     20 6E 6F 74 
     20 75 6E 64 
     65 72 73 74 
     61 6E 64 2E 
     2E 20 54 72 
     79 20 61 67 
     61 69 6E 2E 
     2E 0D 0A 00 I     7       ERR_GARBAGE       .DB "Huh?? Do not understand.. Try again..", CR, LF, NULL
C331-57 72 6F 6E 
     67 20 6E 75 
     6D 62 65 72 
     20 6F 66 20 
     41 72 67 73 
     2E 0D 0A 00 I     8       ERR_WAR           .DB "Wrong number of Args.", CR, LF, NULL
C349-49 6E 76 61 
     6C 69 64 20 
     53 74 61 72 
     74 20 61 64 
     64 72 65 73 
     73 2E 0D 0A 
     00          I     9       ERR_INSADR        .DB "Invalid Start address.", CR, LF, NULL
C362-43 61 6E 6E 
     6F 74 20 63 
     68 61 6E 67 
     65 20 45 45 
     50 52 4F 4D 
     2E 0D 0A 00 I    10       ERR_ROM           .DB "Cannot change EEPROM.", CR, LF, NULL
C37A-42 79 74 65 
     20 6F 75 74 
     20 6F 66 20 
     72 61 6E 67 
     65 20 28 30 
     2D 32 35 35 
     29 2E 0D 0A 
     00          I    11       ERR_LGN           .DB "Byte out of range (0-255).", CR, LF, NULL
C397-49 6E 76 61 
     6C 69 64 20 
     55 6E 74 69 
     6C 20 61 64 
     64 72 65 73 
     73 2E 0D 0A 
     00          I    12       ERR_INUADR        .DB "Invalid Until address.", CR, LF, NULL
C3B0-            I    13
C3B0-            I    14
C3B0-55 6E 6B 6E 
     6F 77 6E 20 
     64 65 76 69 
     63 65 20 4E 
     61 6D 65 2E 
     0D 0A 00    I    15       ERR_DVN           .DB "Unknown device Name.", CR, LF, NULL
C3C7-43 68 61 6E 
     6E 65 6C 20 
     69 73 20 61 
     6C 72 65 61 
     64 79 20 6F 
     70 65 6E 2E 
     0D 0A 00    I    16       ERR_CHO           .DB "Channel is already open.", CR, LF, NULL
C3E2-49 6E 76 61 
     6C 69 64 20 
     44 65 73 74 
     69 6E 61 74 
     69 6F 6E 20 
     61 64 64 72 
     65 73 73 2E 
     0D 0A 00    I    17       ERR_INDADR        .DB "Invalid Destination address.", CR, LF, NULL
C401-42 6C 61 6E 
     6B 20 6C 69 
     6E 65 21 21 
     0D 0A 00    I    18       ERR_INP           .DB "Blank line!!", CR, LF, NULL
C410-54 6F 6F 20 
     6D 61 6E 79 
     20 61 72 67 
     73 2E 0D 0A 
     00          I    19       ERR_TMA           .DB "Too many args.", CR, LF, NULL
C421-49 6E 76 61 
     6C 69 64 20 
     41 72 67 2E 
     0D 0A 00    I    20       ERR_INAR          .DB "Invalid Arg.", CR, LF, NULL
C430-49 6E 76 61 
     6C 69 64 20 
     46 69 6C 65 
     20 4E 61 6D 
     65 20 28 38 
     2E 33 29 2E 
     0D 0A 00    I    21       ERR_INFN          .DB "Invalid File Name (8.3).", CR, LF, NULL
C44B-49 6E 76 61 
     6C 69 64 20 
     43 68 61 6E 
     6E 65 6C 20 
     6E 75 6D 62 
     65 72 20 28 
     30 2D 37 29 
     2E 0D 0A 00 I    22       ERR_INCN          .DB "Invalid Channel number (0-7).", CR, LF, NULL
C46B-49 6E 76 61 
     6C 69 64 20 
     44 44 52 20 
     28 72 2C 20 
     77 20 6F 72 
     20 72 77 29 
     2E 0D 0A 00 I    23       ERR_INDDR         .DB "Invalid DDR (r, w or rw).", CR, LF, NULL
C487-41 72 67 20 
     69 73 20 6E 
     6F 74 20 61 
     20 6E 75 6D 
     62 65 72 2E 
     0D 0A 00    I    24       ERR_INNAN         .DB "Arg is not a number.", CR, LF, NULL
C49E-4E 6F 74 20 
     61 62 6C 65 
     20 74 6F 20 
     6F 70 65 6E 
     20 61 20 63 
     68 61 6E 6E 
     65 6C 2E 0D 
     0A 00       I    25       ERR_CHNOP         .DB "Not able to open a channel.", CR, LF, NULL
C4BC-            I    26
C4BC-            I    27
C4BC-            I    28       #*******************************************************************************
C4BC-            I    29       #                 System Messages
C4BC-            I    30       #*******************************************************************************
C4BC-            I    31
C4BC-54 4C 43 6D 
     6F 6E 20 36 
     35 30 32 20 
     53 42 43 20 
     62 79 20 43 
     6C 69 76 65 
     20 54 68 6F 
     6D 61 73 20 
     28 63 29 20 
     32 30 32 31 
     20 76 65 72 
     73 69 6F 6E 
     20          I    32       MonHeader         .DB 'TLCmon 6502 SBC by Clive Thomas (c) 2021 version '
C4ED-30 2E 30 2E 
     34          I    33                         .DB $30+VerMaj,'.',$30+VerMin,'.',$30+VerMnt
C4F2-0D 0A 0D 0A 
     00          I    34                         .DB CR, LF, CR, LF, NULL
C4F7-            I    35
C4F7-74 6C 63 3E 
     20 00       I    36       MonPrompt         .DB 'tlc> ',NULL
C4FD-            I    37
C4FD-            I    38
C4FD-            I    39       #*******************************************************************************
C4FD-            I    40       #                 Print Functions
C4FD-            I    41       #*******************************************************************************
C4FD-            I    42
C4FD-85 90       I    43 (  3) put_str           sta MSG_PTR
C4FF-84 91       I    44 (  3)                   sty MSG_PTR+1
C501-A0 00       I    45 (  2)                   ldy #$00
C503-B1 90       I    46 ( 5*) pes_loop          lda (MSG_PTR),y       # Get the next char in the string
C505-F0 0B       I    47 (2**)                   beq pes_exit          #   NULL means the end
C507-            I    48
C507-20 E5 C1    I    49 (  6)                   jsr put_c             #   Otherwise put the char
C50A-C8          I    50 (  2)                   iny                   # Increment MSGPTR-lo
C50B-D0 F6       I    51 (2**)                   bne pes_loop          #   No roll-over? Loop back for next character
C50D-            I    52
C50D-E6 91       I    53 (  5)                   inc MSG_PTR+1         # MSGPTR-lo rolled over--carry hi byte
C50F-4C 03 C5    I    54 (  3)                   jmp pes_loop          # Now loop back
C512-            I    55
C512-60          I    56 (  6) pes_exit          rts
C513-            I    57
C513-            I    58
C513-            I    59       pr_err_leader     >CPYMSPTR ERR_LEADER
C513-A9 03       IM    1 (  2)                   lda #ERR_LEADER
C515-A0 C3       IM    2 (  2)                   ldy /ERR_LEADER
C517-20 FD C4    I    60 (  6)                   jsr put_str
C51A-60          I    61 (  6)                   rts
C51B-            I    62
C51B-            I    63
C51B-48          I    64 (  3) pr_err_msg        pha
C51C-5A          I    65 (  3)                   phy
C51D-20 13 C5    I    66 (  6)                   jsr pr_err_leader     # Print 'Err: '
C520-7A          I    67 (  4)                   ply
C521-68          I    68 (  4)                   pla
C522-20 FD C4    I    69 (  6)                   jsr put_str        # then the actual error msg
C525-60          I    70 (  6)                   rts
C526-            I    71
C526-            I    72
C526-            I    73       #*******************************************************************************
C526-            I    74       #                 Print Error Messages
C526-            I    75       #*******************************************************************************
C526-            I    76
C526-            I    77                         # Print Unkown Device Name Err msg
C526-            I    78       pr_err_nocmd      >CPYMSPTR ERR_GARBAGE
C526-A9 09       IM    1 (  2)                   lda #ERR_GARBAGE
C528-A0 C3       IM    2 (  2)                   ldy /ERR_GARBAGE
C52A-20 1B C5    I    79 (  6)                   jsr pr_err_msg
C52D-60          I    80 (  6)                   rts
C52E-            I    81
C52E-            I    82
C52E-            I    83                         # Print Arg number Err msg
C52E-            I    84       pr_err_arwr       >CPYMSPTR ERR_WAR
C52E-A9 31       IM    1 (  2)                   lda #ERR_WAR
C530-A0 C3       IM    2 (  2)                   ldy /ERR_WAR
C532-20 1B C5    I    85 (  6)                   jsr pr_err_msg
C535-60          I    86 (  6)                   rts
C536-            I    87
C536-            I    88
C536-            I    89                         # Print Invalid Start Addr Err msg
C536-            I    90       pr_err_inadr      >CPYMSPTR ERR_INSADR
C536-A9 49       IM    1 (  2)                   lda #ERR_INSADR
C538-A0 C3       IM    2 (  2)                   ldy /ERR_INSADR
C53A-20 1B C5    I    91 (  6)                   jsr pr_err_msg
C53D-60          I    92 (  6)                   rts
C53E-            I    93
C53E-            I    94
C53E-            I    95                         # Print Byte out of range Err msg
C53E-            I    96       pr_err_rom        >CPYMSPTR ERR_ROM
C53E-A9 62       IM    1 (  2)                   lda #ERR_ROM
C540-A0 C3       IM    2 (  2)                   ldy /ERR_ROM
C542-20 1B C5    I    97 (  6)                   jsr pr_err_msg
C545-60          I    98 (  6)                   rts
C546-            I    99
C546-            I   100
C546-            I   101                         # Print Byte out of range Err msg
C546-            I   102       pr_err_lgn        >CPYMSPTR ERR_LGN
C546-A9 7A       IM    1 (  2)                   lda #ERR_LGN
C548-A0 C3       IM    2 (  2)                   ldy /ERR_LGN
C54A-20 1B C5    I   103 (  6)                   jsr pr_err_msg
C54D-60          I   104 (  6)                   rts
C54E-            I   105
C54E-            I   106
C54E-            I   107                         # Print Invalid Until Addr Err msg
C54E-            I   108       pr_err_inuadr     >CPYMSPTR ERR_INUADR
C54E-A9 97       IM    1 (  2)                   lda #ERR_INUADR
C550-A0 C3       IM    2 (  2)                   ldy /ERR_INUADR
C552-20 1B C5    I   109 (  6)                   jsr pr_err_msg
C555-60          I   110 (  6)                   rts
C556-            I   111
C556-            I   112       #*******************************************************************************
C556-            I   113       #                 Print System Messages
C556-            I   114       #*******************************************************************************
C556-            I   115
C556-            I   116                         # Print the Startup Banner
C556-            I   117       pr_MonHeader      >CPYMSPTR MonHeader
C556-A9 BC       IM    1 (  2)                   lda #MonHeader
C558-A0 C4       IM    2 (  2)                   ldy /MonHeader
C55A-20 FD C4    I   118 (  6)                   jsr put_str
C55D-60          I   119 (  6)                   rts
C55E-            I   120
C55E-            I   121
C55E-            I   122                         # Print the system prompt
C55E-            I   123       pr_MonPrompt      >CPYMSPTR MonPrompt
C55E-A9 F7       IM    1 (  2)                   lda #MonPrompt
C560-A0 C4       IM    2 (  2)                   ldy /MonPrompt
C562-20 FD C4    I   124 (  6)                   jsr put_str
C565-60          I   125 (  6)                   rts
C566-                337
C566-                338
C566-                339                         .IN misc/pr_conv.inc
C566-            I     1       ################################################################################
C566-            I     2       #                 Print numbers from CMD_IBUF
C566-            I     3       ################################################################################
C566-            I     4
C566-            I     5       ;====  Print byte in A from ASCBYTE ====
C566-5A          I     6 (  3) pr_HEX_byte       phy
C567-20 76 C5    I     7 (  6)                   jsr byt_2_ASC         # Convert byte to ASCII
C56A-A5 A2       I     8 (  3)                   lda ASCBYTE           # get Hi-nyb
C56C-20 E5 C1    I     9 (  6)                   jsr put_c             # and print it
C56F-A5 A3       I    10 (  3)                   lda ASCBYTE+1         # Get Lo-nyb
C571-20 E5 C1    I    11 (  6)                   jsr put_c             # and print it
C574-7A          I    12 (  4)                   ply
C575-60          I    13 (  6)                   rts
C576-            I    14
C576-            I    15
C576-            I    16       ;====  Convert a byte to an ASCII char in ASCBYTE & ASCBYTE+1  ====
C576-48          I    17 (  3) byt_2_ASC         pha                   # Save byte
C577-4A          I    18 (  2)                   lsr a
C578-4A          I    19 (  2)                   lsr a
C579-4A          I    20 (  2)                   lsr a
C57A-4A          I    21 (  2)                   lsr a                 # move to lower nybble
C57B-A8          I    22 (  2)                   tay
C57C-B9 8B C5    I    23 ( 4*)                   lda HEXNUM,y
C57F-85 A2       I    24 (  3)                   sta ASCBYTE           # and store it
C581-68          I    25 (  4)                   pla                   # get the byte back
C582-29 0F       I    26 (  2)                   and #$0F              # get lower nybble
C584-A8          I    27 (  2)                   tay
C585-B9 8B C5    I    28 ( 4*)                   lda HEXNUM,y
C588-85 A3       I    29 (  3)                   sta ASCBYTE+1         # and store it
C58A-60          I    30 (  6)                   rts
C58B-            I    31
C58B-            I    32
C58B-30 31 32 33 
     34 35 36 37 
     38 39 41 42 
     43 44 45 46 I    33       HEXNUM            .DB '0123456789ABCDEF'
C59B-            I    34
C59B-            I    35
C59B-            I    36       ################################################################################
C59B-            I    37       #                 Get numbers from CMD_IBUF
C59B-            I    38       ################################################################################
C59B-            I    39
C59B-            I    40       #*******************************************************************************
C59B-            I    41       #                 Get an ASCII number from the cmdline
C59B-            I    42       #                 On Exit:
C59B-            I    43       #                   Result in HEX_RES and HEX_RES+1
C59B-            I    44       #                   sec = Success, clc = Failure
C59B-            I    45       #*******************************************************************************
C59B-            I    46
C59B-BD 80 03    I    47 ( 4*) get_ASC_number    lda CMD_IBUF,x        # Get a chr
C59E-C9 24       I    48 (  2)                   cmp #DOLLAR           # Is it HEX?
C5A0-F0 03       I    49 (2**)                   beq gan_getHEX        #   Yes, go get a Hex num
C5A2-            I    50
C5A2-4C B9 C5    I    51 (  3)                   jmp get_ASC_dec       #   No, go get a DEC number
C5A5-            I    52
C5A5-4C 0D C6    I    53 (  3) gan_getHEX        jmp get_ASC_hex
C5A8-            I    54
C5A8-            I    55
C5A8-            I    56       #*******************************************************************************
C5A8-            I    57       #                 Get a number in range 0-255
C5A8-            I    58       #*******************************************************************************
C5A8-            I    59
C5A8-20 9B C5    I    60 (  6) get_BYTE          jsr get_ASC_number    # Get a number
C5AB-90 0A       I    61 (2**)                   bcc gby_bexit         # If invalid go exit
C5AD-            I    62
C5AD-A5 A5       I    63 (  3)                   lda HEX_RES+1         # Is hi-byte == 0
C5AF-D0 06       I    64 (2**)                   bne gby_bexit         #   No, go err exit
C5B1-            I    65
C5B1-A5 A4       I    66 (  3) gby_gexit         lda HEX_RES
C5B3-85 BA       I    67 (  3)                   sta BYTE
C5B5-38          I    68 (  2)                   sec
C5B6-60          I    69 (  6)                   rts
C5B7-            I    70
C5B7-18          I    71 (  2) gby_bexit         clc
C5B8-60          I    72 (  6)                   rts
C5B9-            I    73
C5B9-            I    74
C5B9-            I    75       ********************************************************************************
C5B9-            I    76       #                 Convert an ASCII decimal number on the cmd line to binary
C5B9-            I    77       #                 On Exit:
C5B9-            I    78       #                   Result in HEX_RES and HEX_RES+1
C5B9-            I    79       #                   sec = Success, clc = Failure
C5B9-            I    80       #*******************************************************************************
C5B9-            I    81
C5B9-64 A4       I    82 (  3) get_ASC_dec       stz HEX_RES           # Clear result regs
C5BB-64 A5       I    83 (  3)                   stz HEX_RES+1
C5BD-A9 01       I    84 (  2)                   lda #ISDEC
C5BF-85 A8       I    85 (  3)                   sta NUMBASE
C5C1-BD 80 03    I    86 ( 4*) gad_next_digit    lda CMD_IBUF,x         # Get a chr
C5C4-C9 20       I    87 (  2)                   cmp #SPC              # End of #?
C5C6-F0 41       I    88 (2**)                   beq gad_gexit         #   Yes, then exit
C5C8-            I    89
C5C8-C9 2C       I    90 (  2)                   cmp #COMMA            # End of #?
C5CA-F0 3D       I    91 (2**)                   beq gad_gexit         #   Yes, then exit
C5CC-            I    92
C5CC-C9 00       I    93 (  2)                   cmp #NULL             # End of cmd?
C5CE-F0 39       I    94 (2**)                   beq gad_gexit         #   Yes, then exit
C5D0-            I    95
C5D0-20 98 C2    I    96 (  6)                   jsr is_numeric        # Is it numeric?
C5D3-90 36       I    97 (2**)                   bcc gad_bexit         #   No, then err exit
C5D5-            I    98
C5D5-29 0F       I    99 (  2)                   and #$0F              # Convert to binary
C5D7-48          I   100 (  3)                   pha                   #   and save temporarily
C5D8-            I   101
C5D8-            I   102                         >CPYW HEX_RES,TEMP    # Save current result
C5D8-A5 A4       IM    1 (  3)                   lda HEX_RES
C5DA-85 A6       IM    2 (  3)                   sta TEMP
C5DC-A5 A5       IM    3 (  3)                   lda HEX_RES+1
C5DE-85 A7       IM    4 (  3)                   sta TEMP+1
C5E0-            I   103
C5E0-            I   104                         # This bit multiplies the curr result by 10
C5E0-            I   105                         >MULTW2 HEX_RES       #   Multiply by 2
C5E0-06 A4       IM    1 (  5)                   asl HEX_RES
C5E2-26 A5       IM    2 (  5)                   rol   HEX_RES+1
C5E4-            I   106                         >MULTW2 HEX_RES       #   Multiply by 2 again
C5E4-06 A4       IM    1 (  5)                   asl HEX_RES
C5E6-26 A5       IM    2 (  5)                   rol   HEX_RES+1
C5E8-            I   107                         >ADDW HEX_RES,TEMP    #   Add original #w
C5E8-18          IM    1 (  2)                   clc
C5E9-A5 A4       IM    2 (  3)                   lda HEX_RES
C5EB-65 A6       IM    3 (  3)                   adc TEMP
C5ED-85 A4       IM    4 (  3)                   sta HEX_RES
C5EF-A5 A5       IM    5 (  3)                   lda HEX_RES+1
C5F1-65 A7       IM    6 (  3)                   adc TEMP+1
C5F3-85 A5       IM    7 (  3)                   sta HEX_RES+1
C5F5-            I   108                         >MULTW2 HEX_RES       #   Multiply by 2
C5F5-06 A4       IM    1 (  5)                   asl HEX_RES
C5F7-26 A5       IM    2 (  5)                   rol   HEX_RES+1
C5F9-68          I   109 (  4)                   pla                   # Get new #
C5FA-18          I   110 (  2)                   clc                   #   and add it to the last result
C5FB-65 A4       I   111 (  3)                   adc HEX_RES
C5FD-85 A4       I   112 (  3)                   sta HEX_RES
C5FF-A9 00       I   113 (  2)                   lda #$00
C601-65 A5       I   114 (  3)                   adc HEX_RES+1
C603-85 A5       I   115 (  3)                   sta HEX_RES+1
C605-E8          I   116 (  2)                   inx                   # Inc line ptr
C606-4C C1 C5    I   117 (  3)                   jmp gad_next_digit
C609-            I   118
C609-38          I   119 (  2) gad_gexit         sec                   # sec = success
C60A-60          I   120 (  6)                   rts
C60B-            I   121
C60B-18          I   122 (  2) gad_bexit         clc                   # clc = failure
C60C-60          I   123 (  6)                   rts
C60D-            I   124
C60D-            I   125
C60D-            I   126       #*******************************************************************************
C60D-            I   127       #                 Convert an ASCII Hex number on the cmd line to binary
C60D-            I   128       #*******************************************************************************
C60D-            I   129
C60D-64 A4       I   130 (  3) get_ASC_hex       stz HEX_RES           # clear the result regs
C60F-64 A5       I   131 (  3)                   stz HEX_RES+1
C611-A9 00       I   132 (  2)                   lda #ISHEX
C613-85 A8       I   133 (  3)                   sta NUMBASE
C615-E8          I   134 (  2) gah_loop          inx                   # inc line ptr
C616-BD 80 03    I   135 ( 4*)                   lda CMD_IBUF,x        # Get a chr
C619-C9 20       I   136 (  2)                   cmp #SPC              # End of #?
C61B-F0 23       I   137 (2**)                   beq gah_gexit         #   Yes, then exit
C61D-            I   138
C61D-C9 2C       I   139 (  2)                   cmp #COMMA            # End of #?
C61F-F0 1F       I   140 (2**)                   beq gah_gexit         #   Yes, then exit
C621-            I   141
C621-C9 00       I   142 (  2)                   cmp #NULL             # End of cmd?
C623-F0 1B       I   143 (2**)                   beq gah_gexit         #   Yes, then exit
C625-            I   144
C625-20 44 C6    I   145 (  6)                   jsr get_ASC_nybl      # Is it valid # ?
C628-90 18       I   146 (2**)                   bcc gah_bexit         #   No, go to err exit
C62A-            I   147
C62A-            I   148                         >MULTW2 HEX_RES       #   Yes, so shift left the result 4 times
C62A-06 A4       IM    1 (  5)                   asl HEX_RES
C62C-26 A5       IM    2 (  5)                   rol   HEX_RES+1
C62E-            I   149                         >MULTW2 HEX_RES
C62E-06 A4       IM    1 (  5)                   asl HEX_RES
C630-26 A5       IM    2 (  5)                   rol   HEX_RES+1
C632-            I   150                         >MULTW2 HEX_RES
C632-06 A4       IM    1 (  5)                   asl HEX_RES
C634-26 A5       IM    2 (  5)                   rol   HEX_RES+1
C636-            I   151                         >MULTW2 HEX_RES
C636-06 A4       IM    1 (  5)                   asl HEX_RES
C638-26 A5       IM    2 (  5)                   rol   HEX_RES+1
C63A-            I   152
C63A-05 A4       I   153 (  3)                   ora HEX_RES           # Add in the new nybble
C63C-85 A4       I   154 (  3)                   sta HEX_RES
C63E-80 D5       I   155 (2**)                   bra gah_loop
C640-            I   156
C640-38          I   157 (  2) gah_gexit         sec                   # sec = success
C641-60          I   158 (  6)                   rts
C642-            I   159
C642-18          I   160 (  2) gah_bexit         clc                   # clc = failure
C643-60          I   161 (  6)                   rts
C644-            I   162
C644-            I   163
C644-            I   164       #*******************************************************************************
C644-            I   165       #                 Conv ASC to hex nibble.
C644-            I   166       #                 On Exit: clc = ERR, sec = Valid, A = number
C644-            I   167       #*******************************************************************************
C644-            I   168
C644-38          I   169 (  2) get_ASC_nybl      sec
C645-E9 30       I   170 (  2)                   sbc #$30              # Subtract  ASCII '0'
C647-C9 0A       I   171 (  2)                   cmp #$0A              # Is it a number?
C649-90 0E       I   172 (2**)                   bcc gan_gexit         #   Yes, then go good exit
C64B-            I   173
C64B-E9 07       I   174 (  2)                   sbc #$07              # Subtract diff '9' - 'A'
C64D-C9 10       I   175 (  2)                   cmp #$10              # Is it 'A' - 'F'?
C64F-90 08       I   176 (2**)                   bcc gan_gexit         #   Yes, then go good exit
C651-            I   177
C651-E9 20       I   178 (  2)                   sbc #$20              # Must be lowercase, subtract diff
C653-C9 10       I   179 (  2)                   cmp #$10              # Is it less than 16?
C655-90 02       I   180 (2**)                   bcc gan_gexit         #   Yes, then go good exit
C657-            I   181
C657-18          I   182 (  2) gan_bexit         clc                   #   No, bad ch err exi
C658-60          I   183 (  6)                   rts
C659-            I   184
C659-38          I   185 (  2) gan_gexit         sec
C65A-60          I   186 (  6)                   rts
C65B-            I   187
C65B-            I   188
C65B-            I   189
C65B-20 F9 C2    I   190 (  6) pr_SRC_addr       jsr pr_DOLLAR         ; Format is $xxxx
C65E-A5 B7       I   191 (  3)                   lda SRC+1
C660-20 66 C5    I   192 (  6)                   jsr pr_HEX_byte
C663-A5 B6       I   193 (  3)                   lda SRC
C665-20 66 C5    I   194 (  6)                   jsr pr_HEX_byte
C668-60          I   195 (  6)                   rts
C669-                340
C669-                341
C669-                342       ###############################################################################
C669-                343       #                 System Data Tables and other config stuff
C669-                344       ###############################################################################
C669-                345
C669-                346                         .IN cmdline/cmds_table.inc
C669-            I     1       #*******************************************************************************
C669-            I     2       #                 Table of cmds and their format
C669-            I     3       #*******************************************************************************
C669-            I     4
C669-            I     5       #====  Each cmd can be no more than 8 chr INCLUDING the NULL terminator  ====
C669-            I     6       #====  $                : prefix denotes a hex number otherwise it's a decimal number
C669-            I     7       #====  n                : a single digit 0-9 or letter A-F
C669-            I     8       #====  n..      : one or more digits
C669-            I     9       #====  x                : a single letter
C669-            I    10       #====  a                : a single letter or number
C669-            I    11       #====  ext      : xxx
C669-            I    12       #====  count,
C669-            I    13       #====  addr     : $n[n][n][n] | n[n..] in range 0-65535
C669-            I    14       #====  src,
C669-            I    15       #====  until,
C669-            I    16       #====  dest     : addr
C669-            I    17       #====  dbyte    : $n[n] | n[n..] in range 0-255
C669-            I    18       #====  file     : A file on the SD
C669-            I    19       #====  ch       : n
C669-            I    20       #====  file     : x[a..7].ext
C669-            I    21       #====  chname   : x[a.7]
C669-            I    22       #====  dev      : V | K | R | S | I | D | P
C669-            I    23       #====  dir      : r | w | rw
C669-            I    24
C669-            I    25
C669-            I    26       # COMMANDS FORMAT
C669-            I    27       VALID_CMDS
C669-            I    28                         #==== Returns the DB at location addr
C669-50 45 45 4B 
     00 00 00 00 I    29                         .DB "PEEK", NULL, NULL, NULL, NULL              # peek addr
C671-            I    30
C671-            I    31                         #==== Writes DB at location addr
C671-50 4F 4B 45 
     00 00 00 00 I    32                         .DB "POKE", NULL, NULL, NULL, NULL              # poke addr,dbyte
C679-            I    33
C679-            I    34                         #====  Display a hex dump of mem from addr for either count or 100 dbytes
C679-44 55 4D 50 
     00 00 00 00 I    35                         .DB "DUMP", NULL, NULL, NULL, NULL              # dump addr[,count]
C681-            I    36
C681-            I    37                         #====  Copy memory block src-until to dest
C681-43 4F 50 59 
     00 00 00 00 I    38                         .DB "COPY", NULL, NULL, NULL, NULL              # copy src,until,dest
C689-            I    39
C689-            I    40                         #====  Fill memory range src-until with DB
C689-46 49 4C 4C 
     00 00 00 00 I    41                         .DB "FILL", NULL, NULL, NULL, NULL              # fill src,until,dbyte
C691-            I    42
C691-            I    43                         #====  Edit memory starting at addr
C691-4D 45 4D 45 
     44 00 00 00 I    44                         .DB "MEMED", NULL, NULL, NULL                   # memed addr
C699-            I    45
C699-            I    46                         #====  Execute code at location addr
C699-47 4F 00 00 
     00 00 00 00 I    47                         .DB "GO", NULL, NULL, NULL, NULL, NULL, NULL    # exec addr
C6A1-            I    48
C6A1-            I    49                         #====  Dis-assemble memory from src to either until or 100 dbytes
C6A1-44 49 53 4D 
     00 00 00 00 I    50                         .DB "DISM", NULL, NULL, NULL, NULL              # dism src[,until]
C6A9-            I    51
C6A9-            I    52                         #====  Display help page
C6A9-48 45 4C 50 
     00 00 00 00 I    53                         .DB "HELP", NULL, NULL, NULL, NULL              # help
C6B1-            I    54
C6B1-            I    55                         #====  Convert a number from one base to another
C6B1-48 45 58 44 
     45 43 00 00 I    56                         .DB "HEXDEC", NULL, NULL                        # hexnum [$]n[n..]
C6B9-            I    57
C6B9-00          I    58                         .DB NULL                                        # Cmd-Table end-marker is a NULL
C6BA-            I    59
C6BA-            I    60       VALID_ARGCNT
C6BA-01          I    61                         .DB 1
C6BB-02          I    62                         .DB 2
C6BC-02          I    63                         .DB 2
C6BD-03          I    64                         .DB 3
C6BE-03          I    65                         .DB 3
C6BF-01          I    66                         .DB 1
C6C0-02          I    67                         .DB 2
C6C1-01          I    68                         .DB 1
C6C2-01          I    69                         .DB 1
C6C3-                347
C6C3-                348
C6C3-                349                         .IN cmdline/cmds_jmp_table.inc
C6C3-            I     1       CMD_JUMP_TABLE
C6C3-71 C9       I     2                         .DW cmd_peek
C6C5-A9 C9       I     3                         .DW cmd_poke
C6C7-E9 C9       I     4                         .DW cmd_dump
C6C9-AD CA       I     5                         .DW cmd_copy
C6CB-AE CA       I     6                         .DW cmd_fill
C6CD-AF CA       I     7                         .DW cmd_memed
C6CF-B0 CA       I     8                         .DW cmd_go
C6D1-B1 CA       I     9                         .DW cmd_dism
C6D3-B3 CA       I    10                         .DW cmd_help
C6D5-B2 CA       I    11                         .DW cmd_hexdec
C6D7-                350
C6D7-                351
C6D7-                352       ###############################################################################
C6D7-                353       #                 COMMANDS functions
C6D7-                354       ###############################################################################
C6D7-                355
C6D7-                356                         .IN cmds/cmd_help.inc
C6D7-            I     1       ################################################################################
C6D7-            I     2       #                 Help menu functions and messages
C6D7-            I     3       ################################################################################
C6D7-            I     4
C6D7-41 76 61 69 
     6C 61 62 6C 
     65 20 43 6F 
     6D 6D 61 6E 
     64 73 3A 0D 
     0A 00       I     5       HLP_HDR         .DB 'Available Commands:', CR, LF, NULL
C6ED-            I     6
C6ED-70 65 65 6B 
     20 61 64 64 
     72 20 20 20 
     20 20 20 20 
     20 20 20 20 
     20 20 20 2D 
     20 52 65 74 
     75 72 6E 73 
     20 62 79 74 
     65 20 61 74 
     20 61 64 64 
     72 2E 0D 0A 
     00          I     7       HLP_PEEK          .DB 'peek addr              - Returns byte at addr.', CR, LF, NULL
C71E-70 6F 6B 65 
     20 61 64 64 
     72 2C 62 79 
     74 65 20 20 
     20 20 20 20 
     20 20 20 2D 
     20 53 74 6F 
     72 65 20 62 
     79 74 65 20 
     61 74 20 61 
     64 64 72 2E 
     0D 0A 00    I     8       HLP_POKE          .DB 'poke addr,byte         - Store byte at addr.', CR, LF, NULL
C74D-64 75 6D 70 
     20 61 64 64 
     72 2C 64 65 
     73 74 20 20 
     20 20 20 20 
     20 20 20 2D 
     20 53 68 6F 
     77 20 68 65 
     78 2D 64 75 
     6D 70 20 66 
     72 6F 6D 20 
     61 64 64 72 
     2C 20 66 6F 
     72 20 31 32 
     38 62 79 74 
     65 73 20 6F 
     72 20 74 6F 
     20 64 65 73 
     74 2E 0D 0A 
     00          I     9       HLP_DUMP          .DB 'dump addr,dest         - Show hex-dump from addr, for 128bytes or to dest.', CR, LF, NULL
C79A-            I    10
C79A-            I    11
C79A-63 6F 70 79 
     20 61 64 64 
     72 2C 75 6E 
     74 69 6C 20 
     64 65 73 74 
     20 20 20 2D 
     20 43 6F 70 
     79 20 62 6C 
     6B 20 66 72 
     6F 6D 2D 75 
     6E 74 69 6C 
     20 74 6F 20 
     64 65 73 74 
     2E 0D 0A 00 I    12       HLP_COPY          .DB 'copy addr,until dest   - Copy blk from-until to dest.', CR, LF, NULL
C7D2-66 69 6C 6C 
     20 61 64 64 
     72 2C 75 6E 
     74 69 6C 20 
     62 79 74 65 
     20 20 20 2D 
     20 46 69 6C 
     6C 20 62 6C 
     6B 20 66 72 
     6F 6D 2D 75 
     6E 74 69 6C 
     20 77 69 74 
     68 20 62 79 
     74 65 2E 0D 
     0A 00       I    13       HLP_FILL          .DB 'fill addr,until byte   - Fill blk from-until with byte.', CR, LF, NULL
C80C-68 65 78 64 
     65 63 20 5B 
     24 5D 6E 5B 
     6E 2E 2E 5D 
     20 20 20 20 
     20 20 20 2D 
     20 43 6F 6E 
     76 65 72 74 
     20 6E 75 6D 
     20 66 72 6F 
     6D 20 6F 6E 
     65 20 62 61 
     73 65 20 74 
     6F 20 61 6E 
     6F 74 68 65 
     72 2E 0D 0A 
     00          I    14       HLP_HEXDEC        .DB 'hexdec [$]n[n..]       - Convert num from one base to another.', CR, LF, NULL
C84D-6D 65 6D 65 
     64 20 61 64 
     64 72 20 20 
     20 20 20 20 
     20 20 20 20 
     20 20 20 2D 
     20 4C 69 6E 
     65 20 65 64 
     69 74 20 6D 
     65 6D 20 66 
     72 6F 6D 20 
     61 64 64 72 
     2E 0D 0A 00 I    15       HLP_MEMED         .DB 'memed addr             - Line edit mem from addr.', CR, LF, NULL
C881-65 78 65 63 
     20 61 64 64 
     72 20 20 20 
     20 20 20 20 
     20 20 20 20 
     20 20 20 2D 
     20 52 75 6E 
     20 63 6F 64 
     65 20 73 74 
     61 72 74 69 
     6E 67 20 61 
     74 20 61 64 
     64 72 2E 0D 
     0A 00       I    16       HLP_EXEC          .DB 'exec addr              - Run code starting at addr.', CR, LF, NULL
C8B7-64 69 73 6D 
     20 61 64 64 
     72 2C 75 6E 
     74 69 6C 20 
     20 20 20 20 
     20 20 20 2D 
     20 44 69 73 
     61 73 73 65 
     6D 62 6C 65 
     20 6D 65 6D 
     20 62 6C 6B 
     20 61 64 64 
     72 2D 75 6E 
     74 69 6C 2E 
     0D 0A 00    I    17       HLP_DISM          .DB 'dism addr,until        - Disassemble mem blk addr-until.', CR, LF, NULL
C8F2-68 65 6C 70 
     20 20 20 20 
     20 20 20 20 
     20 20 20 20 
     20 20 20 20 
     20 20 20 2D 
     20 53 68 6F 
     77 20 74 68 
     69 73 20 68 
     65 6C 70 20 
     70 61 67 65 
     2E 0D 0A 00 I    18       HLP_HELP          .DB 'help                   - Show this help page.', CR, LF, NULL
C922-            I    19
C922-63 6D 64 20 
     3F 20 20 20 
     20 20 20 20 
     20 20 20 20 
     20 20 20 20 
     20 20 20 2D 
     20 53 68 6F 
     77 73 20 68 
     65 6C 70 20 
     66 6F 72 20 
     63 6D 64 2E 
     0D 0A 00    I    20       HLP_CMDH          .DB 'cmd ?                  - Shows help for cmd.', CR, LF, NULL
C951-            I    21
C951-            I    22
C951-            I    23       pr_hlp_hdr        >CPYMSPTR HLP_HDR
C951-A9 D7       IM    1 (  2)                   lda #HLP_HDR
C953-A0 C6       IM    2 (  2)                   ldy /HLP_HDR
C955-20 FD C4    I    24 (  6)                   jsr put_str
C958-60          I    25 (  6)                   rts
C959-            I    26
C959-            I    27
C959-            I    28       pr_hlp_peek       >CPYMSPTR HLP_PEEK
C959-A9 ED       IM    1 (  2)                   lda #HLP_PEEK
C95B-A0 C6       IM    2 (  2)                   ldy /HLP_PEEK
C95D-20 FD C4    I    29 (  6)                   jsr put_str
C960-60          I    30 (  6)                   rts
C961-            I    31
C961-            I    32
C961-            I    33       pr_hlp_poke       >CPYMSPTR HLP_POKE
C961-A9 1E       IM    1 (  2)                   lda #HLP_POKE
C963-A0 C7       IM    2 (  2)                   ldy /HLP_POKE
C965-20 FD C4    I    34 (  6)                   jsr put_str
C968-60          I    35 (  6)                   rts
C969-            I    36
C969-            I    37
C969-            I    38       pr_hlp_dump       >CPYMSPTR HLP_DUMP
C969-A9 4D       IM    1 (  2)                   lda #HLP_DUMP
C96B-A0 C7       IM    2 (  2)                   ldy /HLP_DUMP
C96D-20 FD C4    I    39 (  6)                   jsr put_str
C970-60          I    40 (  6)                   rts
C971-                357                         .IN cmds/cmd_peek.inc
C971-            I     1       #*******************************************************************************
C971-            I     2       #                 Peek Cmd: peek h|addr : Show byte at addr
C971-            I     3       #*******************************************************************************
C971-            I     4
C971-            I     5
C971-A5 9E       I     6 (  3) cmd_peek          lda ARGCNT            # How many args?
C973-C9 01       I     7 (  2)                   cmp #$01              # Expect only one
C975-F0 04       I     8 (2**)                   beq cpe_args          #   Yes, go get 'em
C977-            I     9
C977-20 2E C5    I    10 (  6)                   jsr pr_err_arwr       #   No, Show err msg
C97A-60          I    11 (  6)                   rts                   #   and exit
C97B-            I    12
C97B-A6 9A       I    13 (  3) cpe_args          ldx ARG1              # Get ptr to Arg
C97D-BD 80 03    I    14 ( 4*)                   lda CMD_IBUF,x        # and the ch there
C980-C9 3F       I    15 (  2)                   cmp #HELPME           # Is it cmdhelp?
C982-D0 04       I    16 (2**)                   bne cpe_num           #   No, go test for an addr
C984-            I    17
C984-20 59 C9    I    18 (  6)                   jsr pr_hlp_peek       #   Yes, show help for this cmd
C987-60          I    19 (  6)                   rts                   #   and exit
C988-            I    20
C988-20 33 C1    I    21 (  6) cpe_num           jsr get_SRC_addr      # Attempt to get the addr
C98B-B0 04       I    22 (2**)                   bcs cpe_peek          #   Yes, go do cmd
C98D-            I    23
C98D-20 36 C5    I    24 (  6) cpe_bexit         jsr pr_err_inadr      #   No, show err msg
C990-60          I    25 (  6)                   rts                   #   and exit
C991-            I    26
C991-20 5B C6    I    27 (  6) cpe_peek          jsr pr_SRC_addr       # Print SRC addr
C994-20 D5 C2    I    28 (  6)                   jsr pr_SPC
C997-20 F4 C2    I    29 (  6)                   jsr pr_EQUALS
C99A-20 D5 C2    I    30 (  6)                   jsr pr_SPC
C99D-20 F9 C2    I    31 (  6)                   jsr pr_DOLLAR
C9A0-B2 B6       I    32 (  5)                   lda (SRC)                                             ; Get data
C9A2-20 66 C5    I    33 (  6)                   jsr pr_HEX_byte
C9A5-20 CB C2    I    34 (  6)                   jsr pr_CRLF
C9A8-60          I    35 (  6)                   rts
C9A9-                358                         .IN cmds/cmd_poke.inc
C9A9-            I     1       #*******************************************************************************
C9A9-            I     2       #                 Poke Cmd: poke [h]|addr,byte : Write byte to location addr
C9A9-            I     3       #*******************************************************************************
C9A9-            I     4
C9A9-A5 9E       I     5 (  3) cmd_poke          lda ARGCNT            # How many args?
C9AB-C9 02       I     6 (  2)                   cmp #$02              # Expect two
C9AD-F0 15       I     7 (2**)                   beq cpo_arg1          #   Yes, go get 'em
C9AF-            I     8
C9AF-C9 01       I     9 (  2)                   cmp #$01              # Only one?
C9B1-F0 04       I    10 (2**)                   beq cpo_ishelp        #   Yes, go test for help
C9B3-            I    11
C9B3-20 2E C5    I    12 (  6) cpo_bexit         jsr pr_err_arwr       #   No, Show err msg
C9B6-60          I    13 (  6)                   rts                   #   and exit
C9B7-            I    14
C9B7-A6 9A       I    15 (  3) cpo_ishelp        ldx ARG1              # Get ptr to Arg
C9B9-BD 80 03    I    16 ( 4*)                   lda CMD_IBUF,x        # and the ch there
C9BC-C9 3F       I    17 (  2)                   cmp #HELPME           # Is it cmdhelp?
C9BE-D0 F3       I    18 (2**)                   bne cpo_bexit         #   No, go err exit
C9C0-            I    19
C9C0-20 61 C9    I    20 (  6)                   jsr pr_hlp_poke       #   Yes, show help for this cmd
C9C3-60          I    21 (  6)                   rts                   #   and exit
C9C4-            I    22
C9C4-A6 9A       I    23 (  3) cpo_arg1          ldx ARG1              # Get ptr to Arg1
C9C6-20 33 C1    I    24 (  6)                   jsr get_SRC_addr      # Attempt to get the addr
C9C9-90 0A       I    25 (2**)                   bcc cpo_bexit2        #   No, go err exit
C9CB-            I    26
C9CB-A5 B7       I    27 (  3)                   lda SRC+1             #   Yes, so test for ROM addr ($8100-$FFFF)
C9CD-C9 82       I    28 (  2)                   cmp #$82
C9CF-90 08       I    29 (2**)                   bcc cpo_arg2          #   In RAM, so go poke it ;)
C9D1-            I    30
C9D1-20 3E C5    I    31 (  6)                   jsr pr_err_rom
C9D4-60          I    32 (  6)                   rts
C9D5-            I    33
C9D5-20 36 C5    I    34 (  6) cpo_bexit2        jsr pr_err_inadr      #   No, show err msg
C9D8-60          I    35 (  6)                   rts                   #   and exit
C9D9-            I    36
C9D9-A6 9B       I    37 (  3) cpo_arg2          ldx ARG2              # Get ptr to Arg2
C9DB-20 A8 C5    I    38 (  6)                   jsr get_BYTE          # Attempt to get a byte
C9DE-B0 04       I    39 (2**)                   bcs cpo_poke          #   Yes, go do poke
C9E0-            I    40
C9E0-20 46 C5    I    41 (  6)                   jsr pr_err_lgn        #   No, print err msg
C9E3-60          I    42 (  6)                   rts                   #   and exit
C9E4-            I    43
C9E4-A5 BA       I    44 (  3) cpo_poke          lda BYTE              # Finally, do the poke!
C9E6-92 B6       I    45 (  5)                   sta (SRC)
C9E8-60          I    46 (  6)                   rts
C9E9-                359                         .IN cmds/cmd_dump.inc
C9E9-            I     1       #*******************************************************************************
C9E9-            I     2       #                 Dump Cmd: dump [h]|addr[,dest]
C9E9-            I     3       #                      Show hex dump from addr for default 128 bytes or to dest.
C9E9-            I     4       #
C9E9-            I     5       #                 ### Note: Uses CMD_IBUF as temp storage
C9E9-            I     6       #*******************************************************************************
C9E9-            I     7
C9E9-A5 9E       I     8 (  3) cmd_dump          lda ARGCNT            # How many args?
C9EB-C9 01       I     9 (  2)                   cmp #$01              # Only one?
C9ED-F0 08       I    10 (2**)                   beq cdu_ishelp        #   Yes, go test for help
C9EF-            I    11
C9EF-C9 02       I    12 (  2)                   cmp #$02              # Two args?
C9F1-F0 11       I    13 (2**)                   beq cdu_getargs       #   Yes, go validate args
C9F3-            I    14
C9F3-20 2E C5    I    15 (  6) cdu_bexit         jsr pr_err_arwr       #   No, Show err msg
C9F6-60          I    16 (  6)                   rts                   #   and exit
C9F7-            I    17
C9F7-A6 9A       I    18 (  3) cdu_ishelp        ldx ARG1              # Get ptr to Arg
C9F9-BD 80 03    I    19 ( 4*)                   lda CMD_IBUF,x        # and the ch there
C9FC-C9 3F       I    20 (  2)                   cmp #HELPME           # Is it cmdhelp?
C9FE-            I    21                         ### if not HELPME then is it an addr?
C9FE-            I    22                         ###
C9FE-            I    23                         ###
C9FE-D0 F3       I    24 (2**)                   bne cdu_bexit         #   No, go err exit
CA00-            I    25
CA00-20 69 C9    I    26 (  6)                   jsr pr_hlp_dump       #   Yes, show help for this cmd
CA03-60          I    27 (  6)                   rts                   #   and exit
CA04-            I    28
CA04-A6 9A       I    29 (  3) cdu_getargs       ldx ARG1              # Get ptr to Arg1
CA06-20 33 C1    I    30 (  6)                   jsr get_SRC_addr      # Attempt to get the addr
CA09-B0 04       I    31 (2**)                   bcs cdu_getcnt        #   Yes, go get count
CA0B-            I    32
CA0B-20 36 C5    I    33 (  6)                   jsr pr_err_inadr      #   No, show err msg
CA0E-60          I    34 (  6)                   rts                   #   and exit
CA0F-            I    35
CA0F-A5 9E       I    36 (  3) cdu_getcnt        lda ARGCNT            # How many args?
CA11-C9 01       I    37 (  2)                   cmp #$01
CA13-F0 0B       I    38 (2**)                   beq cdu_dfcnt         #   Only one, so do default count
CA15-            I    39                                               #   Else get end addr from
CA15-A6 9B       I    40 (  3)                   ldx ARG2              #   the 2nd Arg
CA17-20 43 C1    I    41 (  6)                   jsr get_UNTIL_addr    # Attempt to get the UNTIL addr
CA1A-B0 11       I    42 (2**)                   bcs dump_blk          #   Yes, go do cmd
CA1C-            I    43
CA1C-20 4E C5    I    44 (  6)                   jsr pr_err_inuadr     #   No, show err msg
CA1F-60          I    45 (  6)                   rts                   #   and exit
CA20-            I    46
CA20-18          I    47 (  2) cdu_dfcnt         clc                   # UNTIL = SRC + $0100
CA21-A5 B6       I    48 (  3)                   lda SRC               # This is the default
CA23-69 00       I    49 (  2)                   adc #$00
CA25-85 B8       I    50 (  3)                   sta UNTIL
CA27-A5 B7       I    51 (  3)                   lda SRC+1
CA29-69 01       I    52 (  2)                   adc #$01
CA2B-85 B9       I    53 (  3)                   sta UNTIL+1
CA2D-            I    54
CA2D-            I    55       #*******************************************************************************
CA2D-            I    56       # Alternate Entry Point: If SRC and UNTIL contain valid address's
CA2D-            I    57       #*******************************************************************************
CA2D-            I    58
CA2D-A9 10       I    59 (  2) dump_blk          lda #$10                                                      ; 80 width = 16 bytes to show
CA2F-85 A8       I    60 (  3)                   sta BYTECNT
CA31-A0 00       I    61 (  2) cdu_do_row        ldy #$00              # Bytes per line ctr
CA33-20 5B C6    I    62 (  6)                   jsr pr_SRC_addr       # Print the addr '$xxxx'
CA36-            I    63
CA36-20 D5 C2    I    64 (  6)                   jsr pr_SPC            # Put a SPC either side of the colon
CA39-20 FE C2    I    65 (  6)                   jsr pr_COLON
CA3C-20 D5 C2    I    66 (  6)                   jsr pr_SPC
CA3F-80 03       I    67 (2**)                   bra cdu_pr_byte
CA41-            I    68
CA41-20 FE C2    I    69 (  6) cdu_row_cont      jsr pr_COLON
CA44-B2 B6       I    70 (  5) cdu_pr_byte       lda (SRC)             # Get byte from memory
CA46-20 66 C5    I    71 (  6)                   jsr pr_HEX_byte       # and print it
CA49-20 D5 C2    I    72 (  6)                   jsr pr_SPC            # followed by a space
CA4C-            I    73
CA4C-B2 B6       I    74 (  5)                   lda (SRC)             # Now save the ASCII
CA4E-C9 20       I    75 (  2)                   cmp #SPC              # If it's >= than a SPC
CA50-B0 04       I    76 (2**)                   bcs cdu_ch_test       #   Yes, then don't change it
CA52-            I    77
CA52-A9 2E       I    78 (  2)                   lda #'.'              #   No, substitute a '.' for unprintable chars
CA54-80 06       I    79 (2**)                   bra cdu_ASC_save
CA56-            I    80
CA56-C9 7F       I    81 (  2) cdu_ch_test       cmp #$7F
CA58-90 02       I    82 (2**)                   bcc cdu_ASC_save      # it's printable
CA5A-            I    83
CA5A-A9 2E       I    84 (  2)                   lda #'.'              # Substitute a '.' for unprintable chars
CA5C-99 00 04    I    85 (  5) cdu_ASC_save      sta ASCIIDUMP,y       # Finally save it in buffer
CA5F-            I    86                         >INCW SRC             # Inc the mem-ptr
CA5F-E6 B6       IM    1 (  5)                   inc SRC
CA61-D0 02       IM    2 (2**)                   bne :IW_EXIT
CA63-E6 B7       IM    3 (  5)                   inc SRC+1
CA65-            IM    4       :IW_EXIT
CA65-            I    87                         >CMPAD SRC,UNTIL      # Have we finished yet?
CA65-A5 B7       IM    1 (  3)                   lda SRC+1
CA67-C5 B9       IM    2 (  3)                   cmp UNTIL+1
CA69-D0 04       IM    3 (2**)                   bne :CA_EXIT
CA6B-A5 B6       IM    4 (  3)                   lda SRC
CA6D-C5 B8       IM    5 (  3)                   cmp UNTIL
CA6F-            IM    6       :CA_EXIT
CA6F-D0 02       I    88 (2**)                   bne cdu_EOL           #   No, continue
CA71-80 0B       I    89 (2**)                   bra cdu_finish        #   Yes, so go exit
CA73-            I    90
CA73-C8          I    91 (  2) cdu_EOL           iny                   # Inc line byte ctr
CA74-C4 A8       I    92 (  3)                   cpy BYTECNT           # End of row yet?
CA76-D0 CC       I    93 (2**)                   bne cdu_pr_byte       #   No, go print another byte
CA78-            I    94
CA78-20 97 CA    I    95 (  6)                   jsr pr_ASC_dump       #   Yes, Print the ASCIIDUMP
CA7B-4C 31 CA    I    96 (  3)                   jmp cdu_do_row        #   and go do the next row
CA7E-            I    97
CA7E-C4 A8       I    98 (  3) cdu_finish        cpy BYTECNT           # Finish of the last row
CA80-F0 11       I    99 (2**)                   beq cdu_last_ASC_dump # At the end of line? Go print ASC dump
CA82-            I   100
CA82-C8          I   101 (  2) cdu_fill_gap      iny
CA83-C4 A8       I   102 (  3)                   cpy BYTECNT
CA85-F0 0C       I   103 (2**)                   beq cdu_last_ASC_dump
CA87-            I   104
CA87-A2 03       I   105 (  2)                   ldx #$03
CA89-20 DA C2    I   106 (  6)                   jsr pr_XSPC           # Print 3 spaces for each 'missing' byte on the row
CA8C-A9 20       I   107 (  2)                   lda #SPC              # put a SPC in the ASCIIDUMP string
CA8E-99 00 04    I   108 (  5)                   sta ASCIIDUMP,y
CA91-80 EF       I   109 (2**)                   bra cdu_fill_gap
CA93-            I   110
CA93-20 97 CA    I   111 (  6) cdu_last_ASC_dump jsr pr_ASC_dump
CA96-60          I   112 (  6)                   rts
CA97-            I   113
CA97-            I   114
CA97-            I   115       #                 Print ASCII version of the last 16 bytes
CA97-            I   116
CA97-A9 00       I   117 (  2) pr_ASC_dump       lda #NULL             # NULL terminate the string
CA99-99 00 04    I   118 (  5)                   sta ASCIIDUMP,y
CA9C-20 FE C2    I   119 (  6)                   jsr pr_COLON          # Put a separator after the bytes
CA9F-20 D5 C2    I   120 (  6) pad_cont          jsr pr_SPC
CAA2-            I   121                         >CPYMSPTR ASCIIDUMP   # Now print it
CAA2-A9 00       IM    1 (  2)                   lda #ASCIIDUMP
CAA4-A0 04       IM    2 (  2)                   ldy /ASCIIDUMP
CAA6-20 FD C4    I   122 (  6)                   jsr put_str
CAA9-20 CB C2    I   123 (  6)                   jsr pr_CRLF
CAAC-60          I   124 (  6)                   rts
CAAD-                360
CAAD-                361
CAAD-60              362 (  6) cmd_copy          rts
CAAE-60              363 (  6) cmd_fill          rts
CAAF-60              364 (  6) cmd_memed         rts
CAB0-60              365 (  6) cmd_go            rts
CAB1-60              366 (  6) cmd_dism          rts
CAB2-60              367 (  6) cmd_hexdec        rts
CAB3-60              368 (  6) cmd_help          rts
CAB4-                369       ###############################################################################
CAB4-                370       #                 Debug stuff
CAB4-                371       ###############################################################################
CAB4-                372
CAB4-                373                         .IN debug.inc
CAB4-A5 99       I     1 (  3) show_argptrs      lda THISCMD           # Show cmd # and arg count
CAB6-20 66 C5    I     2 (  6)                   jsr pr_HEX_byte
CAB9-            I     3
CAB9-A9 2D       I     4 (  2)                   lda #'-'
CABB-20 E5 C1    I     5 (  6)                   jsr put_c
CABE-            I     6
CABE-A5 9E       I     7 (  3)                   lda ARGCNT
CAC0-20 66 C5    I     8 (  6)                   jsr pr_HEX_byte
CAC3-            I     9
CAC3-A9 3D       I    10 (  2)                   lda #'='
CAC5-20 E5 C1    I    11 (  6)                   jsr put_c
CAC8-            I    12
CAC8-20 D5 C2    I    13 (  6)                   jsr pr_SPC
CACB-            I    14
CACB-A5 9A       I    15 (  3)                   lda ARG1
CACD-20 66 C5    I    16 (  6)                   jsr pr_HEX_byte
CAD0-            I    17
CAD0-20 D5 C2    I    18 (  6)                   jsr pr_SPC
CAD3-            I    19
CAD3-A5 9B       I    20 (  3)                   lda ARG2
CAD5-20 66 C5    I    21 (  6)                   jsr pr_HEX_byte
CAD8-            I    22
CAD8-20 D5 C2    I    23 (  6)                   jsr pr_SPC
CADB-            I    24
CADB-A5 9C       I    25 (  3)                   lda ARG3
CADD-20 66 C5    I    26 (  6)                   jsr pr_HEX_byte
CAE0-            I    27
CAE0-20 D5 C2    I    28 (  6)                   jsr pr_SPC
CAE3-            I    29
CAE3-A2 04       I    30 (  2)                   ldx #4
CAE5-20 DA C2    I    31 (  6)                   jsr pr_XSPC
CAE8-            I    32
CAE8-A5 9F       I    33 (  3)                   lda CMDXPTR
CAEA-20 66 C5    I    34 (  6)                   jsr pr_HEX_byte
CAED-            I    35
CAED-60          I    36 (  6)                   rts
CAEE-                374
CAEE-                375       ###############################################################################
CAEE-                376       #                 System vectors
CAEE-                377       ###############################################################################
CAEE-                378
FFFA                379                         .NO $FFFA
FFFA-05 C2           380                         .DW NMI_vector        # NMI vector
FFFC-00 C0           381                         .DW RESET_Ptr         # RESET vector
FFFE-FB C1           382                         .DW IRQ_vector        # IRQ vector
